# Introduction

one-hook is a carefully crafted collection of React hooks, where each hook does one thing and does it well. Following the Unix philosophy of modularity, each hook is independently packaged and can be installed separately, ensuring minimal bundle size and maximum flexibility.

## Why one-hook?

Many React hook libraries bundle everything together in a single package with barrel exports. While this might seem convenient at first, it comes with several drawbacks:

- **Performance Issues**: Barrel exports slow down TypeScript and bundlers, especially as the library grows.
- **Dependency Hell**: When some hooks don't fit your needs, you end up with multiple hook libraries, each with its own dependencies and potential breaking changes.
- **Editor Bloat**: Autocomplete gets cluttered with duplicate exports from different libraries.
- **Inconsistent Quality**: Bundled libraries often contain hooks of mixed quality - some well-maintained, others neglected.

one-hook addresses these pain points by:

- **Individual Packages**: Each hook is a separate package, improving TypeScript and bundler performance.
- **Clean Autocomplete**: You only see what you've installed, keeping your editor suggestions clean and relevant.
- **Seamless Integration**: Works well alongside other hook libraries without duplicate imports.
- **Unified Versioning**: Update all one-hook packages with a single version change, making maintenance simple.
- **Curated Quality**: Every hook is TypeScript-first and held to high quality standards.

## Key Features

- 🎯 **Single Responsibility**: Each hook does one thing exceptionally well.
- 📦 **Tree-shakeable**: Import only what you need.
- 💪 **TypeScript-first**: Built with TypeScript for excellent type safety and IntelliSense support.
- 🧪 **Well-tested**: Comprehensive test coverage for reliability.
- 📚 **Well-documented**: Clear, concise documentation with practical examples.
- 🔄 **Unified Versioning**: All hooks share the same version number for easy updates and maintenance.

---

# useActions

A simpler and typesafe alternative to useReducer.

## Installation

```package-install
npm install @1hook/use-actions
```

## Quick Start

Define how each action modifies the state:

```tsx twoslash include use-counter
import { defineActions } from '@1hook/use-actions'
// ---cut---
export const useCounter = defineActions((state: number) => ({
  increment: (amount: number) => state + amount,
  decrement: (amount: number) => state - amount,
}))
```

Use the actions in your component:

```tsx twoslash
// @include: use-counter
// ---cut---
const [count, actions] = useCounter(0)

actions.increment(1)
actions.decrement(3)
```

## Build a generic hook

We can leverage typescript generics to build reusable hooks.

Let's build a custom `useArray` hook:

```tsx title="use-array.ts"
export const useArray = defineActions(<T>(items: Array<T>) => ({
  push: (item: T) => [...items, item],
  remove: (item: T) => items.filter((i) => i !== item),
  clear: () => [],
}))
```

We can now use the `useArray` hook in our components:

```tsx twoslash
import { defineActions } from '@1hook/use-actions'

const useArray = defineActions((items: Array<number>) => ({
  push: (item: number) => [...items, item],
  remove: (item: number) => items.filter((i) => i !== item),
  clear: () => [],
}))
// ---cut---
const [items, actions] = useArray([1, 2, 3])

actions.push(4)
actions.remove(2)
actions.clear()
```

---

# useAudioAnalyser

Real-time audio analysis based on the Web Audio API.

## Installation

```package-install
npm install @1hook/use-audio-analyser
```

## Quick Start

```tsx twoslash include import
import { useAudioAnalyser } from '@1hook/use-audio-analyser'
```

Pass the `MediaStream` or `HTMLAudioElement` to analyze to `useAudioAnalyser`.

```tsx twoslash
const stream = new MediaStream()
// @include: import
// ---cut---
useAudioAnalyser(stream, {
  method: 'getByteFrequencyData',
  onData: (data) => console.log(data),
})
```

Check out the [API reference](#api-reference) to learn more about the available methods

## Examples

### 1. Visualize audio frequencies of a media element

Visualize audio frequencies in real-time by analyzing data from an HTML audio element using the `useAudioAnalyser` hook.

```tsx twoslash
import { useAudioAnalyser } from '@1hook/use-audio-analyser'
import { useRef, useState } from 'react'
// ---cut---
function AudioVisualizer() {
  const [data, setData] = useState<number[]>([])
  const [audio, setAudio] = useState<HTMLAudioElement | null>(null)

  useAudioAnalyser(audio, {
    method: 'getByteFrequencyData',
    fftSize: 256, // the resolution of the frequency data
    onData: setData,
  })

  return (
    <div>
      <audio ref={setAudio} src="/path/to/audio.mp3" controls />

      <div className="flex h-64">
        {data.map((value, i) => (
          <div
            key={i}
            style={{
              width: '4px',
              height: '100%',
              transform: `scaleY(${value / 255})`,
              background: 'blue',
            }}
          />
        ))}
      </div>
    </div>
  )
}
```

### 2. Visualize audio frequencies from a microphone

Combine the `useUserMedia` hook to capture microphone input with the `useAudioAnalyser` hook to process and visualize the audio frequency data in real-time.

```tsx twoslash
import { useUserMedia } from '@1hook/use-user-media'
import { useAudioAnalyser } from '@1hook/use-audio-analyser'
import { useState } from 'react'
// ---cut---
function AudioVisualizer() {
  const [data, setData] = useState<number[]>([])
  const media = useUserMedia({ audio: true })

  useAudioAnalyser(media.stream, {
    method: 'getByteFrequencyData',
    fftSize: 256,
    onData: setData,
  })

  return (
    <div>
      <div className="flex h-64">
        {data.map((value, i) => (
          <div
            key={i}
            style={{
              width: '4px',
              height: '100%',
              transform: `scaleY(${value / 255})`,
              background: 'blue',
            }}
          />
        ))}
      </div>

      <button onClick={media.state === 'closed' ? media.open : media.close}>
        {media.state === 'closed' ? 'Start' : 'Stop'} Visualizer
      </button>
    </div>
  )
}
```

### 3. Draw the frequency data on a canvas

This example uses the `useAudioAnalyser` hook to analyze the audio frequency data from an audio element and draw the frequency data on a canvas.

```tsx twoslash
import { useAudioAnalyser } from '@1hook/use-audio-analyser'
import { useRef } from 'react'
// ---cut---
function CanvasVisualizer() {
  const canvasRef = useRef<HTMLCanvasElement | null>(null)
  const audioRef = useRef<HTMLAudioElement | null>(null)

  useAudioAnalyser(audioRef.current, {
    method: 'getByteFrequencyData',
    fftSize: 2048,
    onData(data) {
      const canvas = canvasRef.current
      if (!canvas) return

      const ctx = canvas.getContext('2d')
      if (!ctx) return

      // Clear the canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height)

      // Draw frequency bars
      const barWidth = canvas.width / data.length
      ctx.fillStyle = '#4CAF50'

      data.forEach((value, i) => {
        const barHeight = (value / 255) * canvas.height
        const x = i * barWidth
        const y = canvas.height - barHeight

        ctx.fillRect(x, y, barWidth - 1, barHeight)
      })
    },
  })

  return (
    <div className="flex flex-col items-center gap-4">
      <canvas
        ref={canvasRef}
        width={800}
        height={200}
        className="border border-gray-300"
      />
      <audio ref={audioRef} src="/path/to/audio.mp3" controls />
    </div>
  )
}
```

## API Reference

### Parameters

<TypeTable
  type={{
    source: {
      description: (
        <div>
          The audio source to analyze. Pass <code>null</code> to disable.
        </div>
      ),
      type: 'MediaStream | HTMLMediaElement | null',
      required: true,
    },
    options: {
      description: 'The options for the audio analyzer.',
      type: 'AudioAnalyserOptions',
    },
  }}
/>

<AutoTypeTable
  name="AudioAnalyserOptions"
  description="The options for the audio analyzer."
  path="packages/use-audio-analyser/src/index.ts"
/>

---

# useCookie

A simple typesafe state manager using cookies.

## Features

- **Avoid Layout Shifts:** The state is known by both the client and the server.
- **Built-in Validation:** Validate with [zod](https://zod.dev/), [valibot](https://valibot.dev/), [arktype](https://arktype.dev/) or with a simple function.
- **Tab Sync:** The cookie state is synced across multiple browser tabs.
- **Component Sync:** The cookie state is synced across all components.
- **Fullstack:** Includes server-side utilities for end-to-end type safety.

## Installation

```package-install
npm install @1hook/use-cookie
```

## Quick Start

<Steps>

<Step>
### Place the Provider (once per App)

Put a `"use client"` directive on the Provider:

```tsx twoslash title="cookie-provider.tsx"
'use client'
export { ServerCookieProvider } from '@1hook/use-cookie'
```

Place it at the root of your application, in a [Server Component](https://react.dev/reference/rsc/server-components)

```tsx twoslash title="providers.tsx"
// @noErrors
import { headers } from 'next/headers'
import { ServerCookieProvider } from './cookie-provider'

export async function Providers(props: { children: ReactNode }) {
  return (
    <ServerCookieProvider value={(await headers()).get('cookie')}>
      {props.children}
    </ServerCookieProvider>
  )
}
```

</Step>

<Step>
### Setup a cookie

Use defineCookie to configure validation rules and expiration settings for the cookie.

```ts twoslash title="sidebar-width.ts" include cookies
import { z } from 'zod'
import { defineCookie } from '@1hook/use-cookie'

export const [useSidebarWidth] = defineCookie({
  name: 'sidebar-width',
  validate: z.number().default(200),
  expires: 365, // days from now
  sameSite: 'lax',
})
```

</Step>

<Step>
### Read and Write.

Changes to the cookie are synchronized across all instances of the hook and across browser tabs.

```tsx twoslash title="layout.tsx"
function Sidebar(props: { width: number; onResize: (width: number) => void }) {
  return <div />
}

// @noErrors
// @include: cookies
// ---cut---
function Layout() {
  const [width, setWidth] = useSidebarWidth()

  return (
    <div>
      <Sidebar width={width} onResize={setWidth} />
      <main>...</main>
    </div>
  )
}
```

</Step>

</Steps>

## Validation

To ensure data integrity, cookies should be validated.

### 👉 Functional validation

For simple cases you can use a function to validate the cookie value.

```ts twoslash
import { defineCookie } from '@1hook/use-cookie'
// ---cut---
defineCookie({
  name: 'search',
  validate: (value) => String(value ?? ''),
})
```

### 👉 Schema validation

For more complex cases you can use a schema to validate the cookie value. Compatible validation libraries include [zod 3.24+](https://zod.dev/), [valibot
1.0+](https://valibot.dev/) or [arktype 2.0+](https://arktype.dev/). Check out [Standard
Schema](https://github.com/standard-schema/standard-schema) for more info.

```ts twoslash
import { defineCookie } from '@1hook/use-cookie'
// ---cut---
import { z } from 'zod'

defineCookie({
  name: 'search',
  validate: z.string().default(''),
})
```

## Outside of React

`defineCookie` returns a standalone utility object that provides methods to `get`, `set` or `clear` the cookie outside of React components.

```ts twoslash include cookies-outside
import { z } from 'zod'
import { defineCookie } from '@1hook/use-cookie'
// ---cut---
export const [useCookie, Cookie] = defineCookie({
  name: 'my-cookie',
  validate: z.string().optional(),
  expires: 7,
})
```

Using it still triggers a **React re-render**.

```tsx twoslash
// @noErrors
// @include: cookies-outside
// ---cut---
import { Cookie } from './cookie'

// Write
Cookie.set('new-value')

// Read
Cookie.get()

// Clear
Cookie.clear()
```

## On the server

The Cookie utility can read cookies from the cookie header.

```tsx twoslash
// @noErrors
// @include: cookies-outside
import { headers } from 'next/headers'
import { Cookie } from './cookie'
// ---cut---
const cookieHeader = (await headers()).get('cookie')

const token = Cookies.get(cookieHeader)
```

<hr />

## API Reference

### 👉 defineCookies

```ts
function defineCookie(options: DefineCookieOptions): [useCookie, Cookie]
```

<AutoTypeTable
  name="DefineCookieOptions"
  description="The options of the cookie."
  path="packages/use-cookie/src/index.ts"
/>

### 👉 ServerCookieProvider

You can skip this component when building Single Page Applications (SPA).

In SSR frameworks it should be rendered at the top of the component tree, and must be used within a server component.

```tsx
function CookieProvider(props: Props): ReactNode
```

<AutoTypeTable
  title="Props"
  name="ServerCookieProviderProps"
  description="The props of the ServerCookieProvider component."
  path="packages/use-cookie/src/define-cookie.tsx"
/>

### 👉 useCookie

Manage cookie state like with useState.

```ts
function useCookie(): [state, setState]
```

### 👉 Cookie

Read and write the cookie outside of React.

---

# useCountdown

Countdown utility based on useInterval.

## Installation

```package-install
npm install @1hook/use-countdown
```

## Usage

```tsx twoslash include imports
import { useCountdown } from '@1hook/use-countdown'
```

Get the remaining milliseconds:

```tsx twoslash
// @include: imports
// ---cut---
const milliseconds = useCountdown({
  to: '2026-01-01',
})
```

Transform the remaining time in seconds:

```tsx twoslash
// @include: imports
// ---cut---
const seconds = useCountdown({
  to: '2026-01-01',
  transform: (ms) => Math.ceil(ms / 1000),
})
```

Use a custom interval between each tick:

```tsx twoslash
// @include: imports
// ---cut---
const seconds = useCountdown({
  to: '2026-01-01',
  interval: 100,
})
```

Prevent rerendering the component on every tick:

```tsx twoslash
// @include: imports
// ---cut---
useCountdown({
  to: '2026-01-01',
  trackState: false,
  onTick: (ms) => console.log(ms),
})
```

Synchronize all countdowns using the same interval:

```tsx twoslash
// @include: imports
// ---cut---
const milliseconds = useCountdown({
  to: '2026-01-01',
  sync: true,
})
```

Add more details on the current countdown state:

```tsx twoslash
// @include: imports
// ---cut---
const { seconds, state } = useCountdown({
  to: '2026-01-01',
  transform(ms, to) {
    const seconds = Math.ceil(ms / 1000)
    return {
      state: to ? (seconds <= 0 ? 'expired' : 'ticking') : 'idle',
      seconds,
    }
  },
})
```

## API Reference

<AutoTypeTable
  name="UseCountdownOptions"
  path="packages/use-countdown/src/index.ts"
  description="The options of the `useCountdown` hook."
/>

---

# useDebounceFn

A debounce function, reactified.

Ensures that a function is only executed after a specified delay following the last invocation.

## Installation

```package-install
npm install @1hook/use-debounce-fn
```

## Usage

```tsx twoslash include imports
import { useDebounceFn } from '@1hook/use-debounce-fn'
```

The `useDebounceFn` hook accepts a delay in milliseconds and returns a `debounce` function.

All calls are delayed until 1000ms have passed since the last invocation,
then only the final call executes.

```tsx twoslash
// @include: imports
// ---cut---
const { debounce } = useDebounceFn(1000)

debounce(() => console.log('Skipped'))
debounce(() => console.log('Executed after 1000ms'))
```

Override the default delay:

```tsx twoslash
// @include: imports
// ---cut---
const { debounce } = useDebounceFn(1000)

debounce(() => console.log('Skipped'))
debounce(() => console.log('Executed after 500ms'), 500)
```

Cancel pending execution:

```tsx twoslash
// @include: imports
// ---cut---
const { debounce, cancel, isPending } = useDebounceFn(1000)

isPending && cancel()
```

When the component unmounts, pending executions are automatically canceled.

## API Reference

<AutoTypeTable
  name="UseDebounceFnReturn"
  description="What `useDebounceFn` returns"
  path="packages/use-debounce-fn/src/index.ts"
/>

---

# useDebounceValue

Debounce a value.

## Installation

```package-install
npm install @1hook/use-debounce-value
```

## Usage

```tsx twoslash include imports
import { useDebounceValue } from '@1hook/use-debounce-value'
```

Debounce a **state** or a **prop**:

```tsx twoslash
// @include: imports
const value = 'Hello' as string
// ---cut---
const debounced = useDebounceValue(value, 500)

// `debounced` will update 500ms after the last change of `value`
```

Pending indicator:

```tsx twoslash
// @include: imports
const value = 'Hello' as string
// ---cut---
const debounced = useDebounceValue(value, 500)

const pending = debounced !== value
```

---

# useDisplayMedia

React hook to access and manage screen sharing capabilities using the Screen Capture API.

## Installation

```package-install
npm install @1hook/use-display-media
```

## Usage

```tsx twoslash include imports
import { useDisplayMedia } from '@1hook/use-display-media'
```

Pass the media constraints to the hook.

```tsx twoslash
// @include: imports
// ---cut---
const { stream, open, close, state, error } = useDisplayMedia({
  video: true,
})
```

The hook follows a simple state machine:

- Initially starts in `"closed"` state with `stream: null`
- Calling `open()` transitions to `"loading"` state while requesting screen sharing access
- On successful access, transitions to `"open"` state with `stream: MediaStream`
- If an error occurs during loading, transitions to `"error"` state with the error details
- Calling `close()` returns to `"closed"` state, stops the stream, and sets `stream: null`

This predictable state flow makes it easy to build UIs that respond appropriately to the screen sharing status.

## Example

Capture and display the device's screen:

```tsx twoslash
import { useEffect, useRef } from 'react'
import { useDisplayMedia } from '@1hook/use-display-media'

export default function ScreenShare() {
  const { state, stream, error, open, close } = useDisplayMedia({
    video: true,
  })

  const ref = useRef<HTMLVideoElement | null>(null)

  // use the stream to reproduce the video
  useEffect(() => {
    if (!ref.current) return
    ref.current.srcObject = stream
  }, [stream])

  return (
    <div>
      <video ref={ref} autoPlay />

      <button onClick={state === 'closed' ? open : close}>
        {state === 'open' ? 'Stop Sharing' : 'Share Screen'}
      </button>
    </div>
  )
}
```

## API Reference

<AutoTypeTable
  name="UseDisplayMediaOptions"
  description={
    <>
      The options of the useDisplayMedia hook. See&nbsp;
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia#options">
        MDN docs
      </a>
      &nbsp; for more details.
    </>
  }
  path="packages/use-display-media/src/index.ts"
/>
<AutoTypeTable
  name="UseDisplayMediaReturn"
  description="Return value of the useDisplayMedia hook."
  path="packages/use-display-media/src/index.ts"
/>

---

# useDocumentHasFocus

Track the focus state of the document.

## Installation

```package-install
npm install @1hook/use-document-has-focus
```

## Usage

```tsx twoslash include imports
import { useDocumentHasFocus } from '@1hook/use-document-has-focus'
```

Track the document visibility:

```tsx twoslash
// @include: imports
// ---cut---
const hasFocus = useDocumentHasFocus()
```

## API Reference

<AutoTypeTable
  name="UseDocumentHasFocusOptions"
  description="The options for the useDocumentHasFocus hook."
  path="packages/use-document-has-focus/src/index.ts"
/>

---

# useDocumentVisibility

Track the visibility of the document.

## Installation

```package-install
npm install @1hook/use-document-visibility
```

## Usage

```tsx twoslash include imports
import { useDocumentVisibility } from '@1hook/use-document-visibility'
```

Track the document visibility:

```tsx twoslash
// @include: imports
// ---cut---
const isVisible = useDocumentVisibility()
```

## API Reference

<AutoTypeTable
  name="UseDocumentVisibilityOptions"
  description="The options for the useDocumentVisibility hook."
  path="packages/use-document-visibility/src/index.ts"
/>

---

# useEventHandler

Stabilize a function's reference across renders. The function is always up to date in effects and DOM events.

## Installation

```package-install
npm install @1hook/use-event-handler
```

## Usage

```tsx twoslash include imports
import { useEventHandler } from '@1hook/use-event-handler'
```

Provide a function to `useEventHandler`:

```tsx twoslash include onData
// @include: imports
const props = {
  onData: (data: any) => {},
}
// ---cut---
const onData = useEventHandler(props.onData)
```

`onData` now has a stable identity, making it safe to use in `useEffect`.

```tsx twoslash
import { useEffect } from 'react'
// @include: onData
// ---cut---
useEffect(() => {
  // only runs once
}, [onData])
```

---

# useEventListener

React version of `addEventListener`, optimized for performance and memory usage.

## Features

- Reuses the same event listener instance for the same target, type, and options.
- Automatically attaches and detaches the event listener when the component unmounts.
- Provides methods to manually attach and detach the event listener.

## Installation

```package-install
npm install @1hook/use-event-listener
```

## Usage

```tsx twoslash include imports
import { useEventListener } from '@1hook/use-event-listener'
```

Attach an event listener to the target.

```tsx twoslash
// @include: imports
const target = document.getElementById('target')
// ---cut---
useEventListener(target, 'click', () => console.log('click'))
```

## Examples

### 1. Listen to a Window event

SPA example:

```tsx twoslash
// @include: imports
const target = document.getElementById('target')
// ---cut---
useEventListener(window, 'click', (e) => console.log(e.target))
```

SSR example:

```tsx twoslash
// @include: imports
const target = document.getElementById('target')
// ---cut---
import { isServer } from '@1hook/use-event-listener'

useEventListener(!isServer && window, 'click', (e) => console.log(e.target))
```

`!isServer && window` ensures the code is runs the client before accessing the
window object

### 2. Targeting a DOM Element

You can use `useEventListener` to attach event listeners to specific DOM elements.

Using a ref:

```tsx twoslash
// @include: imports
import { useRef } from 'react'
// ---cut---
function MyComponent() {
  const ref = useRef<HTMLDivElement | null>(null)

  useEventListener(ref, 'scroll', (e) => console.log('scroll'))

  return <div ref={ref} />
}
```

Using a stateful element:

```tsx twoslash
// @include: imports
import { useState } from 'react'
// ---cut---
function MyComponent() {
  const [target, setTarget] = useState<HTMLDivElement | null>(null)

  useEventListener(target, 'scroll', (e) => console.log('scroll'))

  return <div ref={setTarget} />
}
```

Using querySelector:

```tsx twoslash
// @include: imports
// ---cut---
function MyComponent() {
  const target = document.querySelector('body > .scrollable')

  useEventListener(target, 'scroll', (e) => console.log('scroll'))

  return <div />
}
```

### 3. Trigger the listener manually

This example shows how to listen for the `'mousemove'` & `'mouseup'` global events only after the `'mousedown'` event has occurred.

```tsx twoslash
// @include: imports
// ---cut---
useEventListener(document.getElementById('target'), 'mousedown', (e) => {
  // Activate mousemove and mouseup listeners after mousedown occurs
  mousemoveListener.add()
  mouseupListener.add()
})

const mousemoveListener = useEventListener(
  document,
  'mousemove',
  (e) => console.log('Mouse Move'),
  { autoListen: false }, // Do not attach the listener automatically
)

const mouseupListener = useEventListener(
  document,
  'mouseup',
  (e) => {
    // Remove both listeners after mouseup event
    mousemoveListener.remove()
    mouseupListener.remove()
  },
  { autoListen: false }, // Do not attach the listener automatically
)
```

## API Reference

<TableTitle value="Parameters" />

<TableDescription
  value={
    <>
      The <code>useEventListener</code> hook accepts four arguments:
    </>
  }
/>

| Argument                             | Description                                                                                                                                                                                                                                                                     |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <pre>(1) <Code>target</Code></pre>   | The element to attach the listener to.                                                                                                                                                                                                                                          |
| <pre>(2) <Code>type</Code></pre>     | See [MDN Docs](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#parameters)                                                                                                                                                                        |
| <pre>(3) <Code>listener</Code></pre> | See [MDN Docs](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#parameters)                                                                                                                                                                        |
| <pre>(4) <Code>options</Code></pre>  | Event listener options (see [MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#parameters)) with the following differences:<br/>- `autoListen`: if `false` the listener is not attached automatically on mount.<br/>- `signal` is omitted |

<AutoTypeTable
  name="UseEventListenerReturn"
  description="What `useEventListener` returns"
  path="packages/use-event-listener/src/index.ts"
/>

---

# useGeolocation

Access and watch the browser's geolocation data.

## Installation

```package-install
npm install @1hook/use-geolocation
```

## Usage

```tsx twoslash include imports
import { useGeolocation } from '@1hook/use-geolocation'
```

When mounted, this hook begins tracking the user's location. \
If location permissions haven't been granted yet, the browser will request permission from the user.

```tsx twoslash
// @include: imports
// ---cut---
function LocationDisplay() {
  const { coords, state, error } = useGeolocation()

  if (state === 'loading') {
    return <div>Loading location...</div>
  }

  if (state === 'error') {
    return <div>Error: {error.message}</div>
  }

  return (
    <div>
      <div>Latitude: {coords.latitude}</div>
      <div>Longitude: {coords.longitude}</div>
    </div>
  )
}
```

## API Reference

<AutoTypeTable
  name="UseGeolocationOptions"
  description={
    <>
      Options for the <code>useGeolocation</code> hook. See&nbsp;
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition#parameters">
        MDN docs
      </a>
      &nbsp; for more details.
    </>
  }
  path="packages/use-geolocation/src/index.ts"
/>

<AutoTypeTable
  name="UseGeolocationReturn"
  description={
    <>
      The return value of the <code>useGeolocation</code> hook.
    </>
  }
  path="packages/use-geolocation/src/index.ts"
/>

---

# useGetIsMounted

Check if a component is still mounted to avoid memory leaks.

## Installation

```package-install
npm install @1hook/use-get-is-mounted
```

## Usage

```tsx twoslash include imports
import { useGetIsMounted } from '@1hook/use-get-is-mounted'
```

Get the mounted state of the component at any time

```tsx twoslash
// @include: imports
// ---cut---
const getIsMounted = useGetIsMounted()

console.log(getIsMounted())
```

---

# useGlobalState

Minimalistic & Performant global state manager.

## Installation

```package-install
npm install @1hook/use-global-state
```

## Quick Start

<Steps>

<Step>
### Define the global state

```tsx twoslash title="use-count.ts" include use-count
import { defineGlobalState } from '@1hook/use-global-state'

export const [useCount] = defineGlobalState({ initialState: 0 })
```

</Step>

<Step>
### Use like useState

```tsx twoslash
// @include: use-count
// ---cut---
const [count, setCount] = useCount()
```

</Step>
</Steps>

## Prevent unnecessary rerenders

To help prevent unnecessary rerenders, `defineGlobalState` provides a standalone setter function. \
It helps prevent unnecessary rerenders by not listening to the state.

```tsx twoslash title="use-count.ts" include set-count
import { defineGlobalState } from '@1hook/use-global-state'
// ---cut---
export const [useCount, setCount] = defineGlobalState({ initialState: 0 })
```

✅ No rerender when count changes:

```tsx twoslash
// @noErrors
// @include: set-count
// ---cut---
import { setCount } from './use-count'

function Increment1() {
  return (
    <button onClick={() => setCount((count) => count + 1)}>Increment</button>
  )
}
```

❌ Rerenders when count changes:

```tsx twoslash
// @noErrors
// @include: set-count
// ---cut---
import { useCount } from './use-count'

function Increment1() {
  const [count, setCount] = useCount()

  return (
    <button onClick={() => setCount((count) => count + 1)}>Increment</button>
  )
}
```

---

# useInView

Track the visibility of an element.

## Installation

```package-install
npm install @1hook/use-in-view
```

## Usage

```tsx twoslash include imports
import { useInView } from '@1hook/use-in-view'
```

Track the visibility of an element:

```tsx twoslash
// @include: imports
// ---cut---
function MyComponent() {
  const { ref, inView } = useInView()

  return <div ref={ref}>...</div>
}
```

Set a default value until the target is observed:

```tsx twoslash
// @include: imports
// ---cut---
function MyComponent() {
  const { ref, inView = true } = useInView()

  return <div ref={ref}>...</div>
}
```

Customize the intersection observer:

```tsx twoslash
// @include: imports
// ---cut---
function MyComponent() {
  const { ref, inView } = useInView({
    root: document.querySelector('#root'),
    rootMargin: '10px',
    threshold: 0.5,
  })

  return <div ref={ref}>...</div>
}
```

Observe once:

```tsx twoslash
// @include: imports
// ---cut---
function MyComponent() {
  const { ref, unobserve } = useInView({
    onChange: (inView) => inView && unobserve(),
  })

  return <div ref={ref}>...</div>
}
```

## API Reference

<AutoTypeTable
  name="UseInViewOptions"
  description="Options for the useInView hook."
  path="packages/use-in-view/src/index.ts"
/>

<AutoTypeTable
  name="UseInViewReturn"
  description="Return value for the useInView hook."
  path="packages/use-in-view/src/index.ts"
/>

---

# useIntersectionObserver

The IntersectionObserver API, reactified, simplified and optimized.

## Features

- **Instance Reuse:** Optimizes performance by reusing IntersectionObserver instances based on options.
- **Convenient Unwrapping:** Automatically unwraps the entries parameter, allowing direct access to each entry in the callback.
- **Manual Observation Control:** Allows manual control over observation using the `observe` and `unobserve` functions.

## Installation

```package-install
npm install @1hook/use-intersection-observer
```

## Usage

```tsx twoslash include imports
import { useIntersectionObserver } from '@1hook/use-intersection-observer'
```

Observe an element's intersection with the viewport:

```tsx twoslash
// @include: imports
// ---cut---
function MyComponent() {
  const { ref } = useIntersectionObserver((entry) => {
    console.log({ isIntersecting: entry.isIntersecting })
  })

  return <div ref={ref} />
}
```

Customize the intersection observer:

```tsx twoslash
// @include: imports
// ---cut---
function MyComponent() {
  const { ref } = useIntersectionObserver(
    (entry) => console.log({ isIntersecting: entry.isIntersecting }),
    { rootMargin: '100px' },
  )

  return <div ref={ref} />
}
```

Stop observing the target after the first intersection:

```tsx twoslash
// @include: imports
// ---cut---
function MyComponent() {
  const { ref, unobserve } = useIntersectionObserver((entry) => {
    if (!entry.isIntersecting) return
    console.log('Intersected!')
    unobserve()
  })

  return <div ref={ref} />
}
```

## API Reference

<AutoTypeTable
  name="UseIntersectionObserverOptions"
  description="Options for the useIntersectionObserver hook."
  path="packages/use-intersection-observer/src/index.ts"
/>

<AutoTypeTable
  name="UseIntersectionObserverReturn"
  description="Return value for the useIntersectionObserver hook."
  path="packages/use-intersection-observer/src/index.ts"
/>

---

# useInterval

setInterval reactified, with synchronization support.

## Installation

```package-install
npm install @1hook/use-interval
```

## Usage

```tsx twoslash include imports
import { useInterval } from '@1hook/use-interval'
```

Set an interval:

```tsx twoslash
// @include: imports
// ---cut---
const { cancel, reset, isPending } = useInterval(() => {
  console.log('Hello')
}, 1000)
```

Pause the interval by setting the delay to `null`:

```ts twoslash
// @include: imports
// ---cut---
useInterval(() => console.log('Hello'), null)
```

Execute immediately by setting the `leading` option to `true`:

```ts twoslash
// @include: imports
// ---cut---
useInterval(() => console.log('Hello'), 1000, { leading: true })
```

Synchronize all intervals that share the same delay using the `sync` option:

```ts twoslash
// @include: imports
// ---cut---
useInterval(() => console.log('Hello'), 1000, { sync: true })
```

## API Reference

<AutoTypeTable
  name="UseIntervalOptions"
  description="Options for the useInterval hook (3rd argument)."
  path="packages/use-interval/src/index.ts"
/>

<AutoTypeTable
  name="UseIntervalReturn"
  description="Return value of the useInterval hook."
  path="packages/use-interval/src/index.ts"
/>

---

# useInvariantContext

useContext that throws if the provider is not found.

## Installation

```package-install
npm install @1hook/use-invariant-context
```

## Usage

```tsx twoslash include imports
import { createContext } from 'react'
type Value = any[]
const MyContext = React.createContext<Value | null>(null)
// ---cut---
import { useInvariantContext } from '@1hook/use-invariant-context'
```

An error is thrown if the context value is falsy.

```tsx twoslash
// @include: imports
// @noErrors
// ---cut---
const ctx = useInvariantContext(MyContext)

// optionally pass a custom error message

const ctx = useInvariantContext(MyContext, 'Context not found')
```

## Example

This example shows how to use `useInvariantContext` to avoid missing context provider.

```tsx twoslash
import { useInvariantContext } from '@1hook/use-invariant-context'
import { createContext, ReactNode, useContext } from 'react'
type Value = any[]
// @noErrors
// ---cut---
const MyContext = createContext<Value | null>(null)

type Props = { children: ReactNode; initialValue: Value }

export function MyProvider({ children, initialValue }: Props) {
  return (
    <MyContext.Provider value={initialValue}>{children}</MyContext.Provider>
  )
}

// ❌ returns `Value | null` since there is not garantee that the context provider is present
export const useMyContext = () => useContext(MyContext)

// ✅ returns `Value` or throws an error if the context provider is not found
export const useMyContext = () => useInvariantContext(MyContext)
```

---

# useIsHydrated

Once `true`, no hydration error can occur.

Prevent hydration mismatches by conditionally rendering content that depends on browser APIs.

## Installation

```package-install
npm install @1hook/use-is-hydrated
```

## Usage

```tsx twoslash include imports
import { useIsHydrated } from '@1hook/use-is-hydrated'
```

Check if the component is hydrated:

```tsx twoslash
// @include: imports
// ---cut---
function MyComponent() {
  const isHydrated = useIsHydrated()

  if (!isHydrated) return null

  return <div>{Date.now()}</div>
}
```

---

# useIsOnline

Track the online state of the browser.

## Installation

```package-install
npm install @1hook/use-is-online
```

## Usage

```tsx twoslash include imports
import { useIsOnline } from '@1hook/use-is-online'
```

Check if the browser is online:

```tsx twoslash
// @include: imports
// ---cut---
const isOnline = useIsOnline()
```

---

# useLatestRef

Transform anything into a ref. The ref is always up to date in effects and DOM events.

## Installation

```package-install
npm install @1hook/use-latest-ref
```

## Usage

```tsx twoslash include imports
import { useLatestRef } from '@1hook/use-latest-ref'
```

Transform any value into a ref:

```tsx twoslash
// @include: imports
type Value = any[]
const value: Value = []
// ---cut---
const ref = useLatestRef(value)
```

Use `ref.current` to read the latest `value` in effects, changes to `value` do not trigger the effect.

```tsx twoslash
// @include: imports
import { useEffect } from 'react'
type Value = any[]
const value: Value = []
const ref = useLatestRef(value)
// ---cut---
useEffect(() => {
  // only runs once
  console.log('value', ref.current)
}, [ref])
```

---

# useLockBodyScroll

Lock and unlock the body scroll without layout shift.

## Installation

```package-install
npm install @1hook/use-lock-body-scroll
```

## Usage

```tsx twoslash include imports
import { useLockBodyScroll } from '@1hook/use-lock-body-scroll'
```

The body scroll is automatically unlocked when the hook unmounts.

```tsx twoslash
// @include: imports
// ---cut---
const { lock, unlock, locked } = useLockBodyScroll()
```

Lock on mount:

```tsx twoslash
import { useEffect } from 'react'
// @include: imports
// ---cut---
const { lock } = useLockBodyScroll()

useEffect(lock, [lock])
```

---

# useMediaRecorder

Record media streams.

## Installation

```package-install
npm install @1hook/use-media-recorder
```

## Usage

```tsx twoslash include imports
const stream = new MediaStream()
//---cut---
import { useMediaRecorder } from '@1hook/use-media-recorder'
```

The recording automatically starts when a media stream is provided and stops when the stream is nullish.

```tsx twoslash
// @include: imports
import { useState } from 'react'
const [recordingSrc, setRecordingSrc] = useState<string>()
// ---cut---
useMediaRecorder(stream, {
  onComplete(chunks) {
    const blob = new Blob(chunks, { type: 'video/webm' })
    const url = URL.createObjectURL(blob)
    setRecordingSrc(url)
  },
})
```

You can pause and resume the recording:

```tsx twoslash
// @include: imports
// ---cut---
const { pause, resume } = useMediaRecorder(stream, {
  onComplete(chunks) {
    // transform the chunks into a file or url
  },
})
```

Transform the recorded data into a File:

```tsx twoslash
// @include: imports
import { useState } from 'react'
const [file, setFile] = useState<File>()
// ---cut---
const { pause, resume } = useMediaRecorder(stream, {
  onComplete(chunks) {
    const type = 'video/webm'
    const blob = new Blob(chunks, { type })
    const file = new File([blob], 'recording.webm', { type })
    setFile(file)
  },
})
```

## Example

Record video from the device's camera:

```tsx twoslash include imports
import { useMediaRecorder } from '@1hook/use-media-recorder'
import { useUserMedia } from '@1hook/use-user-media'
import { useState } from 'react'

export default function VideoRecorder() {
  const [recordingSrc, setRecordingSrc] = useState<string>()

  const media = useUserMedia({ video: true })

  const recorder = useMediaRecorder(media.stream, {
    onComplete(chunks) {
      const blob = new Blob(chunks, { type: 'video/webm' })
      const src = URL.createObjectURL(blob)
      setRecordingSrc(src)
    },
  })

  return (
    <div>
      {recordingSrc && <video src={recordingSrc} controls />}

      {recorder.state === 'inactive' && (
        <button onClick={media.open}>Start Recording</button>
      )}
      {recorder.state === 'recording' && (
        <button onClick={media.close}>Stop Recording</button>
      )}
    </div>
  )
}
```

## API Reference

<AutoTypeTable
  name="UseMediaRecorderOptions"
  description={
    <>
      The options of the useMediaRecorder hook. See&nbsp;
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/MediaRecorder#options">
        MDN docs
      </a>
      &nbsp; for more details.
    </>
  }
  path="packages/use-media-recorder/src/index.ts"
/>

<AutoTypeTable
  name="UseMediaRecorderReturn"
  description="The return value of the useMediaRecorder hook."
  path="packages/use-media-recorder/src/index.ts"
/>

---

# useMergeRefs

Merge refs, returns a callback ref.

## Installation

```package-install
npm install @1hook/use-merge-refs
```

## Usage

```tsx twoslash include imports
import { useMergeRefs } from '@1hook/use-merge-refs'
```

Merge refs:

```tsx twoslash
// @include: imports
import { useRef } from 'react'
const forwardedRef = useRef<HTMLDivElement | null>(null)
const internalRef = useRef<HTMLDivElement | null>(null)
// ---cut---
const ref = useMergeRefs(forwardedRef, internalRef)
```

`ref` is a callback ref.

---

# useMountEffect

Execute the callback when the component mounts (first effect).

## Installation

```package-install
npm install @1hook/use-mount-effect
```

## Usage

```tsx twoslash include imports
import { useMountEffect } from '@1hook/use-mount-effect'
```

Execute a function on mount:

```tsx twoslash
// @include: imports
// ---cut---
useMountEffect(() => console.log('Mounted!'))
```

---

# useMutationObserver

The MutationObserver API, reactified and simplified

## Installation

```package-install
npm install @1hook/use-mutation-observer
```

## Usage

```tsx twoslash include imports
import { useMutationObserver } from '@1hook/use-mutation-observer'
```

Observe an element’s child list mutation:

```tsx twoslash
// @include: imports
// ---cut---
function MyComponent() {
  const { ref } = useMutationObserver(
    (entry) => console.log("The element's child list has changed!"),
    { childList: true },
  )

  return <div ref={ref} />
}
```

Manual observation control:

```tsx twoslash
// @include: imports
// ---cut---
function MyComponent() {
  const { ref, observe, unobserve } = useMutationObserver(
    (entry) => console.log("The element's child list has changed!"),
    { childList: true, autoObserve: false }, // Disable automatic observation
  )

  return (
    <div>
      <div ref={ref} />

      <button onClick={observe}>Start observing</button>

      <button onClick={unobserve}>Stop observing</button>
    </div>
  )
}
```

## API Reference

<AutoTypeTable
  name="UseMutationObserverOptions"
  description={
    <>
      The options for the useMutationObserver hook. See&nbsp;
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe#options">
        MDN docs
      </a>
      &nbsp;for more details.
    </>
  }
  path="packages/use-mutation-observer/src/index.ts"
/>

<AutoTypeTable
  name="UseMutationObserverReturn"
  description="The return value of the useMutationObserver hook."
  path="packages/use-mutation-observer/src/index.ts"
/>

---

# useNavigatorPermission

Query and track navigator permissions.

## Installation

```package-install
npm install @1hook/use-navigator-permission
```

## Usage

```tsx twoslash include imports
import { useNavigatorPermission } from '@1hook/use-navigator-permission'
```

Query a permission state:

```tsx twoslash
// @include: imports
// ---cut---
const permission = useNavigatorPermission({ name: 'geolocation' })

console.log(permission.state)
```

The state will be updated in real-time as the user interacts with the browser.

## API Reference

<AutoTypeTable
  name="UseNavigatorPermissionOptions"
  description="The options for the useNavigatorPermission hook."
  path="packages/use-navigator-permission/src/index.ts"
/>

<AutoTypeTable
  name="UseNavigatorPermissionReturn"
  description="The return value of the useNavigatorPermission hook."
  path="packages/use-navigator-permission/src/index.ts"
/>

---

# usePrevious

Returns the previous value.

## Installation

```package-install
npm install @1hook/use-previous
```

## Usage

```tsx twoslash include imports
import { usePrevious } from '@1hook/use-previous'
```

Get the previous value:

```tsx twoslash
// @include: imports
const value: number = 0
// ---cut---
const previous = usePrevious(value)
```

Custom `isEqual` function to compare the previous and current values.

```tsx
import { isEqual } from 'lodash'

const previous = usePrevious(value, { isEqual })
```

## API Reference

<AutoTypeTable
  name="UsePreviousOptions"
  description="The options for the usePrevious hook."
  path="packages/use-previous/src/index.ts"
/>

---

# useRerender

Trigger rerenders on-demand.

## Installation

```package-install
npm install @1hook/use-rerender
```

## Usage

```tsx twoslash include imports
import { useRerender } from '@1hook/use-rerender'
```

Rerender a component:

```tsx twoslash
// @include: imports
// ---cut---
const rerender = useRerender()

rerender()
```

---

# useResizeObserver

The React version of the ResizeObserver API.

## Installation

```package-install
npm install @1hook/use-resize-observer
```

## Usage

```tsx twoslash include imports
import { useResizeObserver } from '@1hook/use-resize-observer'
```

Observe an element:

```tsx twoslash
// @include: imports
// ---cut---
function MyComponent() {
  const { ref } = useResizeObserver((entry) => {
    console.log('The target element has been resized!')
  })

  return <div ref={ref} />
}
```

Manual observation control:

```tsx twoslash
// @include: imports
// ---cut---
function MyComponent() {
  const { ref, observe, unobserve } = useResizeObserver(
    (entry) => console.log('Resized!'),
    { autoObserve: false }, // Disable automatic observation
  )

  return (
    <div>
      <div ref={ref} />

      <button onClick={observe}>Start observing</button>

      <button onClick={unobserve}>Stop observing</button>
    </div>
  )
}
```

## API Reference

<AutoTypeTable
  name="UseResizeObserverOptions"
  description={
    <>
      The options for the useResizeObserver hook. See&nbsp;
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/observe#options">
        MDN docs
      </a>
      for more details.
    </>
  }
  path="packages/use-resize-observer/src/index.ts"
/>

<AutoTypeTable
  name="UseResizeObserverReturn"
  description="The return value of the useResizeObserver hook."
  path="packages/use-resize-observer/src/index.ts"
/>

---

# useSize

Track the size of an element.

## Installation

```package-install
npm install @1hook/use-size
```

## Usage

```tsx twoslash include imports
import { useSize } from '@1hook/use-size'
```

Observe an element:

```tsx twoslash
// @include: imports
// ---cut---
function MyComponent() {
  const { ref, width, height } = useSize()

  return <div ref={ref}>...</div>
}
```

Provide default values:

```tsx twoslash
// @include: imports
// ---cut---
const { ref, width = 0, height = 0 } = useSize()
```

## API Reference

<AutoTypeTable
  name="UseSizeOptions"
  description="The options for the useSize hook."
  path="packages/use-size/src/index.ts"
/>

<AutoTypeTable
  name="UseSizeReturn"
  description="The return value of the useSize hook."
  path="packages/use-size/src/index.ts"
/>

---

# useSpeechSynthesis

Web Speech API synthesis, reactified.

## Installation

```package-install
npm install @1hook/use-speech-synthesis
```

## Usage

```tsx twoslash include imports
import { useSpeechSynthesis } from '@1hook/use-speech-synthesis'
```

Basic text-to-speech:

```tsx twoslash
// @include: imports
// ---cut---
const { speak } = useSpeechSynthesis()

speak('Hello, world!')
```

Configure speech options:

```tsx twoslash
// @include: imports
// ---cut---
const { speak } = useSpeechSynthesis({
  lang: 'fr-FR',
  pitch: 1.5,
  rate: 0.8,
  volume: 0.7,
})

speak('Bonjour le monde!')
```

Cancel speaking and check the current state:

```tsx twoslash
// @include: imports
// ---cut---
const { speak, cancel, state } = useSpeechSynthesis()

console.log(state) // state === 'idle'
speak('Hello, world!')
console.log(state) // state === 'speaking'
cancel()
console.log(state) // state === 'idle'
```

## API Reference

<AutoTypeTable
  name="UseSpeechSynthesisOptions"
  description={
    <>
      The options for the useSpeechSynthesis hook. See&nbsp;
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesisUtterance">
        MDN docs
      </a>
      &nbsp;for more details.
    </>
  }
  path="packages/use-speech-synthesis/src/index.ts"
/>

<AutoTypeTable
  name="UseSpeechSynthesisReturn"
  description="The return value of the useSpeechSynthesis hook."
  path="packages/use-speech-synthesis/src/index.ts"
/>

---

# useStorage

A simple typesafe state manager using localStorage or sessionStorage.

## Features

- **Built-in Validation:** Validate with [zod](https://zod.dev/), [valibot](https://valibot.dev/), [arktype](https://arktype.dev/) or with a simple function.
- **Tab Sync:** The state is synced across multiple browser tabs when using the `localStorage`.
- **Component Sync:** The state is synced across all components.

## Installation

```package-install
npm install @1hook/use-storage
```

## Quick Start

<Steps>
<Step>
### Setup the State

Use defineCookie to configure validation rules and the type of storage.

```tsx twoslash title="sidebar-width.ts" include sidebar-width
import { z } from 'zod'
import { defineStorage } from '@1hook/use-storage'

export const [useSidebarWidth] = defineStorage({
  key: 'sidebar-width',
  validate: z.number().default(200),
  type: 'local',
})
```

</Step>

<Step>
### Read and Write.

Changes to the state are synchronized across all instances of the hook and across browser tabs.

```tsx twoslash title="layout.tsx"
// @noErrors
// @include: sidebar-width
// ---cut---
function Layout() {
  const [width, setWidth] = useSidebarWidth()

  return (
    <div>
      <Sidebar width={width} onResize={setWidth} />
      <main>...</main>
    </div>
  )
}
```

Storage updates are automatically synchronized across all instances of the hook and across browser tabs.

</Step>
</Steps>

## Validation

To ensure data integrity, the storage should be validated.

### 👉 Functional validation

For simple cases you can use a function to validate the storage.

```ts twoslash
import { defineStorage } from '@1hook/use-storage'
// ---cut---
defineStorage({
  key: 'search',
  validate: (value) => String(value ?? ''),
  type: 'local',
})
```

### 👉 Schema validation

For more complex cases you can use a schema to validate the storage. Compatible validation libraries include [zod 3.24+](https://zod.dev/), [valibot
1.0+](https://valibot.dev/) or [arktype 2.0+](https://arktype.dev/). Check out [Standard
Schema](https://github.com/standard-schema/standard-schema) for more info.

```ts twoslash
import { defineStorage } from '@1hook/use-storage'
// ---cut---
import { z } from 'zod'

defineStorage({
  key: 'search',
  validate: z.string().default(''),
  type: 'local',
})
```

## Outside of React

`defineStorage` returns a standalone utility object that provides methods to `get`, `set` or `clear` the value outside of React components.

```ts twoslash include storage-outside
import { z } from 'zod'
import { defineStorage } from '@1hook/use-storage'
// ---cut---
export const [useStorage, Storage] = defineStorage({
  key: 'my-storage',
  validate: z.string().optional(),
  type: 'local',
})
```

Using it still triggers a **React re-render**.

```tsx twoslash
// @noErrors
// @include: storage-outside
// ---cut---
import { Storage } from './storage'

// Write
Storage.set('new-value')

// Read
Storage.get()

// Clear
Storage.clear()
```

<hr />

## API Reference

### 👉 defineStorage

```ts
function defineStorage(options?: DefineStorageOptions): [useStorage, Storage]
```

<AutoTypeTable
  name="DefineStorageOptions"
  description="The options of the storage service."
  path="packages/use-storage/src/index.ts"
/>

### 👉 useStorage

Manage storage state like with useState.

```ts
function useStorage(): [state, setState]
```

### 👉 Storage

Read and write to the storage outside of React.

---

# useThrottleFn

A throttle function, reactified.

Ensures that a function is only executed once in a specified time interval, no matter how many times it is invoked.

## Installation

```package-install
npm install @1hook/use-throttle-fn
```

## Usage

```tsx twoslash include imports
import { useThrottleFn } from '@1hook/use-throttle-fn'
```

The `useThrottleFn` hook accepts an interval in milliseconds and returns a `throttle` function.

The first call executes right away, while subsequent calls within interval are throttled. \
The final call is scheduled to run after the interval expires.

```tsx twoslash
// @include: imports
// ---cut---
const { throttle } = useThrottleFn(1000)

throttle(() => console.log('Executes immediately'))
throttle(() => console.log('Skipped'))
throttle(() => console.log('Scheduled to execute after 1000ms'))
```

Override the default interval:

```diff lang='tsx'
const { throttle } = useThrottleFn(1000)

throttle(() => console.log('Executes immediately'))
throttle(() => console.log('Scheduled to execute after 500ms'), 500)
```

Use `trailing: false` to avoid scheduling the last call:

```tsx twoslash
// @include: imports
// ---cut---
const { throttle } = useThrottleFn(1000, { trailing: false })

throttle(() => console.log('Executes immediately'))
throttle(() => console.log('Skipped'))
```

Cancel pending executions:

```tsx
const { throttle, cancel, isPending } = useThrottleFn(1000)

isPending && cancel()
```

When the component unmounts, pending executions are automatically canceled.

## API Reference

<AutoTypeTable
  name="UseThrottleFnOptions"
  description="The options of the useThrottleFn hook."
  path="packages/use-throttle-fn/src/index.ts"
/>

<AutoTypeTable
  name="UseThrottleFnReturn"
  description="The return value of the useThrottleFn hook."
  path="packages/use-throttle-fn/src/index.ts"
/>

---

# useTimeout

setTimeout, reactified.

## Installation

```package-install
npm install @1hook/use-timeout
```

## Usage

```tsx twoslash include imports
import { useTimeout } from '@1hook/use-timeout'
```

Set a timeout:

```tsx twoslash
// @include: imports
// ---cut---
const { cancel, reset, isPending } = useTimeout(() => {
  console.log('Hello')
}, 1000)
```

Pause the timeout by setting the delay to `null`:

```ts twoslash
// @include: imports
// ---cut---
useTimeout(() => console.log('Hello'), null)
```

## API Reference

<AutoTypeTable
  name="UseTimeoutReturn"
  description="The return value of the useTimeout hook."
  path="packages/use-timeout/src/index.ts"
/>

---

# useUnmountEffect

Execute the callback when the component unmounts (cleanup effect).

## Installation

```package-install
npm install @1hook/use-unmount-effect
```

## Usage

```tsx twoslash include imports
import { useUnmountEffect } from '@1hook/use-unmount-effect'
```

Execute a function on unmount:

```tsx twoslash
// @include: imports
// ---cut---
useUnmountEffect(() => console.log('Unmounted!'))
```

---

# useUpdateEffect

useEffect without the initial effect.

## Installation

```package-install
npm install @1hook/use-update-effect
```

## Usage

```tsx twoslash include imports
import { useUpdateEffect } from '@1hook/use-update-effect'
```

Execute on dependency change:

```tsx twoslash
// @include: imports
const state: string = ''
// ---cut---
useUpdateEffect(() => console.log('State has changed'), [state])
```

---

# useUserMedia

Access and manage media devices like camera and microphone.

## Installation

```package-install
npm install @1hook/use-user-media
```

## Usage

```tsx twoslash include imports
import { useUserMedia } from '@1hook/use-user-media'
```

Pass the media constraints to the hook.

```tsx twoslash
// @include: imports
// ---cut---
const { stream, open, close, state, error } = useUserMedia({
  video: true,
})
```

The hook follows a simple state machine:

- Initially starts in `"closed"` state with `stream: null`
- Calling `open()` transitions to `"loading"` state while requesting device access
- On successful device access, transitions to `"open"` state with `stream: MediaStream`
- If an error occurs during loading, transitions to `"error"` state with the error details
- Calling `close()` returns to `"closed"` state, stops the stream, and sets `stream: null`

This predictable state flow makes it easy to build UIs that respond appropriately to the media stream's status.

## Example

Capture and display video from the device's camera.

```tsx twoslash
import { useEffect, useRef } from 'react'
import { useUserMedia } from '@1hook/use-user-media'

export default function VideoCapture() {
  const { state, stream, open, close } = useUserMedia({
    video: true,
  })

  const ref = useRef<HTMLVideoElement | null>(null)

  // use the stream to reproduce the video
  useEffect(() => {
    if (!ref.current) return
    ref.current.srcObject = stream
  }, [stream])

  return (
    <div>
      <video ref={ref} autoPlay />

      <button onClick={state === 'closed' ? open : close}>
        {state === 'closed' ? 'Open' : 'Close'} Camera
      </button>
    </div>
  )
}
```

### Parameters

<AutoTypeTable
  name="UseUserMediaOptions"
  description={
    <>
      The options of the useUserMedia hook. See&nbsp;
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints">
        MDN docs
      </a>
      &nbsp; for more details.
    </>
  }
  path="packages/use-user-media/src/index.ts"
/>

<AutoTypeTable
  name="UseUserMediaReturn"
  description="The return value of the useUserMedia hook."
  path="packages/use-user-media/src/index.ts"
/>

---

# useWindowSize

Track the dimensions of the window.

## Features

- **Optimized performance:** Leverages a shared listener pool to reduce event subscriptions.
- **Custom state tracking:** disable internal state tracking with `trackState`.
- **Event-driven updates:** Provides an `onChange` callback for reacting to dimension changes.

## Installation

```package-install
npm install @1hook/use-window-size
```

## Usage

```tsx twoslash include imports
import { defineUseWindowSize } from '@1hook/use-window-size'

export const useWindowSize = defineUseWindowSize({ spa: true })
```

`defineUseWindowSize` accepts a `spa` option that enables Single Page Application optimizations. \
When `spa: false` the width and height are initialized with `undefined`.

```tsx twoslash
// @include: imports
// ---cut---
const { width, height } = useWindowSize()
```

Use `trackState: false` to disable state tracking, the `onChange` callback is executed whenever the window size changes.

```tsx twoslash
// @include: imports
// ---cut---
useWindowSize({
  trackState: false,
  onChange(size) {
    if (size.width < 600) {
      // do something
    }
  },
})
```

## API Reference

<AutoTypeTable
  name="DefineUseWindowSizeOptions"
  description="Options for the `defineUseWindowSize` hook."
  path="packages/use-window-size/src/index.ts"
/>

<AutoTypeTable
  name="UseWindowSizeOptions"
  description="Options for the `useWindowSize` hook."
  path="packages/use-window-size/src/index.ts"
/>

<AutoTypeTable
  name="UseWindowSizeReturn"
  description="The return value of the `useWindowSize` hook."
  path="packages/use-window-size/src/index.ts"
/>

---

