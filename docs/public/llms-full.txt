# Introduction

one-hook is a carefully crafted collection of React hooks, where each hook does one thing and does it well. Following the Unix philosophy of modularity, each hook is independently packaged and can be installed separately, ensuring minimal bundle size and maximum flexibility.

[comment]: # "## Why one-hook?'"
[comment]: # 'Many React hook libraries bundle everything together in a single package with barrel exports. While this might seem convenient at first, it comes with several drawbacks:'
[comment]: # '- **Performance Issues**: Barrel exports slow down TypeScript and bundlers, especially as the library grows.'
[comment]: # "- **Dependency Hell**: When some hooks don't fit your needs, you end up with multiple hook libraries, each with its own dependencies and potential breaking changes."
[comment]: # '- **Editor Bloat**: Autocomplete gets cluttered with duplicate exports from different libraries.'
[comment]: # '- **Inconsistent Quality**: Bundled libraries often contain hooks of mixed quality - some well-maintained, others neglected.'
[comment]: # 'one-hook addresses these pain points by:'
[comment]: # '- **Individual Packages**: Each hook is a separate package, improving TypeScript and bundler performance.'
[comment]: # "- **Clean Autocomplete**: You only see what you've installed, keeping your editor suggestions clean and relevant."
[comment]: # '- **Seamless Integration**: Works well alongside other hook libraries without duplicate imports.'
[comment]: # '- **Unified Versioning**: Update all one-hook packages with a single version change, making maintenance simple.'
[comment]: # '- **Curated Quality**: Every hook is TypeScript-first and held to high quality standards.'
[comment]: # '## Key Features'
[comment]: # '- üéØ **Single Responsibility**: Each hook does one thing exceptionally well.'
[comment]: # '- üì¶ **Tree-shakeable**: Import only what you need.'
[comment]: # '- üí™ **TypeScript-first**: Built with TypeScript for excellent type safety and IntelliSense support.'
[comment]: # '- üß™ **Well-tested**: Comprehensive test coverage for reliability.'
[comment]: # '- üìö **Well-documented**: Clear, concise documentation with practical examples.'
[comment]: # '- üîÑ **Unified Versioning**: All hooks share the same version number for easy updates and maintenance. */}'

---

# useActions

A simpler and typesafe alternative to useReducer.

## Installation

```package-install
npm install @1hook/use-actions
```

## Quick Start

Define how each action modifies the state:

```ts twoslash include use-counter
import { defineActions } from '@1hook/use-actions'
// ---cut---
export const useCounter = defineActions((state: number) => ({
  increment: (amount: number) => state + amount,
  decrement: (amount: number) => state - amount,
}))
```

Use the actions in your component:

```ts twoslash
// @include: use-counter
// ---cut---
const [count, actions] = useCounter(0)

actions.increment(1)
actions.decrement(3)
```

## Build a generic hook

We can leverage typescript generics to build reusable hooks.

Let's build a custom `useArray` hook:

```ts title="use-array.ts"
export const useArray = defineActions(<T>(items: Array<T>) => ({
  push: (item: T) => [...items, item],
  remove: (item: T) => items.filter((i) => i !== item),
  clear: () => [],
}))
```

We can now use the `useArray` hook in our components:

```ts twoslash
import { defineActions } from '@1hook/use-actions'

const useArray = defineActions((items: Array<number>) => ({
  push: (item: number) => [...items, item],
  remove: (item: number) => items.filter((i) => i !== item),
  clear: () => [],
}))
// ---cut---
const [items, actions] = useArray([1, 2, 3])

actions.push(4)
actions.remove(2)
actions.clear()
```

---

# useAudioAnalyser

Real-time audio analysis based on the Web Audio API.

## Installation

```package-install
npm install @1hook/use-audio-analyser
```

## Quick Start

```tsx twoslash include import
import { useAudioAnalyser } from '@1hook/use-audio-analyser'
```

Pass the `MediaStream` or `HTMLAudioElement` to analyze to `useAudioAnalyser`.

```tsx twoslash
const console = { log: (_: any) => {} }
const stream = new MediaStream()
// @include: import
// ---cut---
useAudioAnalyser(stream, {
  method: 'getByteFrequencyData',
  onData: (data) => console.log(data),
})
```

Check out the [API reference](#api-reference) to learn more about the available methods

## Examples

### 1. Visualize audio frequencies of a media element

Visualize audio frequencies in real-time by analyzing data from an HTML audio element using the `useAudioAnalyser` hook.

```tsx twoslash
import { useAudioAnalyser } from '@1hook/use-audio-analyser'
import React, { useRef, useState } from 'react'
// ---cut---
function AudioVisualizer() {
  const [data, setData] = useState<number[]>([])
  const [audio, setAudio] = useState<HTMLAudioElement | null>(null)

  useAudioAnalyser(audio, {
    method: 'getByteFrequencyData',
    fftSize: 256, // the resolution of the frequency data
    onData: setData,
  })

  return (
    <div>
      <audio ref={setAudio} src="/path/to/audio.mp3" controls />

      <div className="flex h-64">
        {data.map((value, i) => (
          <div
            key={i}
            style={{
              width: '4px',
              height: '100%',
              transform: `scaleY(${value / 255})`,
              background: 'blue',
            }}
          />
        ))}
      </div>
    </div>
  )
}
```

### 2. Visualize audio frequencies from a microphone

Combine the `useUserMedia` hook to capture microphone input with the `useAudioAnalyser` hook to process and visualize the audio frequency data in real-time.

```tsx twoslash
import { useUserMedia } from '@1hook/use-user-media'
import { useAudioAnalyser } from '@1hook/use-audio-analyser'
import React, { useState } from 'react'
// ---cut---
function AudioVisualizer() {
  const [data, setData] = useState<number[]>([])
  const media = useUserMedia({ audio: true })

  useAudioAnalyser(media.stream, {
    method: 'getByteFrequencyData',
    fftSize: 256,
    onData: setData,
  })

  return (
    <div>
      <div className="flex h-64">
        {data.map((value, i) => (
          <div
            key={i}
            style={{
              width: '4px',
              height: '100%',
              transform: `scaleY(${value / 255})`,
              background: 'blue',
            }}
          />
        ))}
      </div>

      <button onClick={media.state === 'closed' ? media.open : media.close}>
        {media.state === 'closed' ? 'Start' : 'Stop'} Visualizer
      </button>
    </div>
  )
}
```

### 3. Draw the frequency data on a canvas

This example uses the `useAudioAnalyser` hook to analyze the audio frequency data from an audio element and draw the frequency data on a canvas.

```tsx twoslash
import { useAudioAnalyser } from '@1hook/use-audio-analyser'
import React, { useRef } from 'react'
// ---cut---
function CanvasVisualizer() {
  const canvasRef = useRef<HTMLCanvasElement | null>(null)
  const audioRef = useRef<HTMLAudioElement | null>(null)

  useAudioAnalyser(audioRef.current, {
    method: 'getByteFrequencyData',
    fftSize: 2048,
    onData(data) {
      const canvas = canvasRef.current
      if (!canvas) return

      const ctx = canvas.getContext('2d')
      if (!ctx) return

      // Clear the canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height)

      // Draw frequency bars
      const barWidth = canvas.width / data.length
      ctx.fillStyle = '#4CAF50'

      data.forEach((value, i) => {
        const barHeight = (value / 255) * canvas.height
        const x = i * barWidth
        const y = canvas.height - barHeight

        ctx.fillRect(x, y, barWidth - 1, barHeight)
      })
    },
  })

  return (
    <div className="flex flex-col items-center gap-4">
      <canvas
        ref={canvasRef}
        width={800}
        height={200}
        className="border border-gray-300"
      />
      <audio ref={audioRef} src="/path/to/audio.mp3" controls />
    </div>
  )
}
```

## API Reference

### Parameters

<TypeTable
  type={{
    source: {
      description: (
        <div>
          The audio source to analyze. Pass <code>null</code> to disable.
        </div>
      ),
      type: 'MediaStream | HTMLMediaElement | null',
      required: true,
    },
    options: {
      description: 'The options for the audio analyzer.',
      type: 'AudioAnalyserOptions',
    },
  }}
/>

<AutoTypeTable
  name="AudioAnalyserOptions"
  description="The options for the audio analyzer."
  path="packages/use-audio-analyser/src/index.ts"
/>

---

# useCookie

A simple typesafe state manager using cookies.

## Features

- **Avoid Layout Shifts:** The state is known by both the client and the server.
- **Built-in Validation:** Validate with [zod](https://zod.dev/), [valibot](https://valibot.dev/), [arktype](https://arktype.dev/) or with a simple function.
- **Tab Sync:** The cookie state is synced across multiple browser tabs.
- **Component Sync:** The cookie state is synced across all components.
- **Fullstack:** Includes server-side utilities for end-to-end type safety.

## Installation

```package-install
npm install @1hook/use-cookie
```

## Quick Start

<Steps>

<Step>
### Place the Provider (once per App)

Put a `"use client"` directive on the Provider:

```tsx twoslash title="cookie-provider.tsx"
'use client'
export { ServerCookieProvider } from '@1hook/use-cookie'
```

Place it at the root of your application, in a [Server Component](https://react.dev/reference/rsc/server-components)

```tsx twoslash title="providers.tsx"
// @noErrors
import { headers } from 'next/headers'
import { ServerCookieProvider } from './cookie-provider'

export async function Providers(props: { children: ReactNode }) {
  return (
    <ServerCookieProvider value={(await headers()).get('cookie')}>
      {props.children}
    </ServerCookieProvider>
  )
}
```

</Step>

<Step>
### Setup a cookie

Use defineCookie to configure validation rules and expiration settings for the cookie.

```ts twoslash title="sidebar-width.ts" include cookies
import { z } from 'zod'
import { defineCookie } from '@1hook/use-cookie'

export const [useSidebarWidth] = defineCookie({
  name: 'sidebar-width',
  validate: z.number().default(200),
  expires: 365, // days from now
  sameSite: 'lax',
})
```

</Step>

<Step>
### Read and Write.

Changes to the cookie are synchronized across all instances of the hook and across browser tabs.

```tsx twoslash title="layout.tsx"
function Sidebar(props: { width: number; onResize: (width: number) => void }) {
  return <div />
}

// @noErrors
// @include: cookies
// ---cut---
function Layout() {
  const [width, setWidth] = useSidebarWidth()

  return (
    <div>
      <Sidebar width={width} onResize={setWidth} />
      <main>...</main>
    </div>
  )
}
```

</Step>

</Steps>

## Validation

To ensure data integrity, cookies should be validated.

### üëâ Functional validation

For simple cases you can use a function to validate the cookie value.

```ts twoslash
import { defineCookie } from '@1hook/use-cookie'
// ---cut---
defineCookie({
  name: 'search',
  validate: (value) => String(value ?? ''),
})
```

### üëâ Schema validation

For more complex cases you can use a schema to validate the cookie value. Compatible validation libraries include [zod 3.24+](https://zod.dev/), [valibot
1.0+](https://valibot.dev/) or [arktype 2.0+](https://arktype.dev/). Check out [Standard
Schema](https://github.com/standard-schema/standard-schema) for more info.

```ts twoslash
import { defineCookie } from '@1hook/use-cookie'
// ---cut---
import { z } from 'zod'

defineCookie({
  name: 'search',
  validate: z.string().default(''),
})
```

## Outside of React

`defineCookie` returns a standalone utility object that provides methods to `get`, `set` or `clear` the cookie outside of React components.

```ts twoslash include cookies-outside
import { z } from 'zod'
import { defineCookie } from '@1hook/use-cookie'
// ---cut---
export const [useCookie, Cookie] = defineCookie({
  name: 'my-cookie',
  validate: z.string().optional(),
  expires: 7,
})
```

Using it still triggers a **React re-render**.

```tsx twoslash
// @noErrors
// @include: cookies-outside
// ---cut---
import { Cookie } from './cookie'

// Write
Cookie.set('new-value')

// Read
Cookie.get()

// Clear
Cookie.clear()
```

## On the server

The Cookie utility can read cookies from the cookie header.

```tsx twoslash
// @noErrors
// @include: cookies-outside
import { headers } from 'next/headers'
import { Cookie } from './cookie'
// ---cut---
const cookieHeader = (await headers()).get('cookie')

const token = Cookies.get(cookieHeader)
```

<hr />

## API Reference

### üëâ defineCookies

```ts
function defineCookie(options: DefineCookieOptions): [useCookie, Cookie]
```

<AutoTypeTable
  name="DefineCookieOptions"
  description="The options of the cookie."
  path="packages/use-cookie/src/index.ts"
/>

### üëâ ServerCookieProvider

You can skip this component when building Single Page Applications (SPA).

In SSR frameworks it should be rendered at the top of the component tree, and must be used within a server component.

```tsx
function CookieProvider(props: Props): ReactNode
```

<AutoTypeTable
  title="Props"
  name="ServerCookieProviderProps"
  description="The props of the ServerCookieProvider component."
  path="packages/use-cookie/src/define-cookie.tsx"
/>

### üëâ useCookie

Manage cookie state like with useState.

```ts
function useCookie(): [state, setState]
```

### üëâ Cookie

Read and write the cookie outside of React.

---

# useCountdown

Countdown utility based on useInterval.

## Installation

```package-install
npm install @1hook/use-countdown
```

## Usage

```tsx twoslash include imports
import { useCountdown } from '@1hook/use-countdown'
```

Get the remaining milliseconds:

```tsx twoslash
// @include: imports
// ---cut---
const milliseconds = useCountdown({
  to: '2026-01-01',
})
```

Transform the remaining time in seconds:

```tsx twoslash
// @include: imports
// ---cut---
const seconds = useCountdown({
  to: '2026-01-01',
  transform: (ms) => Math.ceil(ms / 1000),
})
```

Use a custom interval between each tick:

```tsx twoslash
// @include: imports
// ---cut---
const seconds = useCountdown({
  to: '2026-01-01',
  interval: 100,
})
```

Prevent rerendering the component on every tick:

```tsx twoslash
const console = { log: (_: any) => {} }
// @include: imports
// ---cut---
useCountdown({
  to: '2026-01-01',
  trackState: false,
  onTick: (ms) => console.log(ms),
})
```

Synchronize all countdowns using the same interval:

```tsx twoslash
// @include: imports
// ---cut---
const milliseconds = useCountdown({
  to: '2026-01-01',
  sync: true,
})
```

Add more details on the current countdown state:

```tsx twoslash
// @include: imports
// ---cut---
const { seconds, state } = useCountdown({
  to: '2026-01-01',
  transform(ms, to) {
    const seconds = Math.ceil(ms / 1000)
    return {
      state: to ? (seconds <= 0 ? 'expired' : 'ticking') : 'idle',
      seconds,
    }
  },
})
```

## API Reference

<AutoTypeTable
  name="UseCountdownOptions"
  path="packages/use-countdown/src/index.ts"
  description="The options of the `useCountdown` hook."
/>

---

# useDebounceFn

A debounce function, reactified.

Ensures that a function is only executed after a specified delay following the last invocation.

## Installation

```package-install
npm install @1hook/use-debounce-fn
```

## Usage

```tsx twoslash include imports
import { useDebounceFn } from '@1hook/use-debounce-fn'
```

The `useDebounceFn` hook accepts a delay in milliseconds and returns a `debounce` function.

All calls are delayed until 1000ms have passed since the last invocation,
then only the final call executes.

```tsx twoslash
const console = { log: (_: any) => {} }
// @include: imports
// ---cut---
const { debounce } = useDebounceFn(1000)

debounce(() => console.log('Skipped'))
debounce(() => console.log('Executed after 1000ms'))
```

Override the default delay:

```tsx twoslash
const console = { log: (_: any) => {} }
// @include: imports
// ---cut---
const { debounce } = useDebounceFn(1000)

debounce(() => console.log('Skipped'))
debounce(() => console.log('Executed after 500ms'), 500)
```

Cancel pending execution:

```tsx twoslash
// @include: imports
// ---cut---
const { debounce, cancel, isPending } = useDebounceFn(1000)

isPending && cancel()
```

When the component unmounts, pending executions are automatically canceled.

## API Reference

<AutoTypeTable
  name="UseDebounceFnReturn"
  description="What `useDebounceFn` returns"
  path="packages/use-debounce-fn/src/index.ts"
/>

---

# useDebounceValue

Debounce a value.

## Installation

```package-install
npm install @1hook/use-debounce-value
```

## Usage

```tsx twoslash include imports
import { useDebounceValue } from '@1hook/use-debounce-value'
```

Debounce a **state** or a **prop**:

```tsx twoslash
// @include: imports
const value = 'Hello' as string
// ---cut---
const debounced = useDebounceValue(value, 500)

// `debounced` will update 500ms after the last change of `value`
```

Pending indicator:

```tsx twoslash
// @include: imports
const value = 'Hello' as string
// ---cut---
const debounced = useDebounceValue(value, 500)

const pending = debounced !== value
```

---

# useDisplayMedia

React hook to access and manage screen sharing capabilities using the Screen Capture API.

## Installation

```package-install
npm install @1hook/use-display-media
```

## Usage

```tsx twoslash include imports
import { useDisplayMedia } from '@1hook/use-display-media'
```

Pass the media constraints to the hook.

```tsx twoslash
// @include: imports
// ---cut---
const { stream, open, close, state, error } = useDisplayMedia({
  video: true,
})
```

The hook follows a simple state machine:

- Initially starts in `"closed"` state with `stream: null`
- Calling `open()` transitions to `"loading"` state while requesting screen sharing access
- On successful access, transitions to `"open"` state with `stream: MediaStream`
- If an error occurs during loading, transitions to `"error"` state with the error details
- Calling `close()` returns to `"closed"` state, stops the stream, and sets `stream: null`

This predictable state flow makes it easy to build UIs that respond appropriately to the screen sharing status.

## Example

Capture and display the device's screen:

```tsx twoslash
import React, { useEffect, useRef } from 'react'
import { useDisplayMedia } from '@1hook/use-display-media'

export default function ScreenShare() {
  const { state, stream, error, open, close } = useDisplayMedia({
    video: true,
  })

  const ref = useRef<HTMLVideoElement | null>(null)

  // use the stream to reproduce the video
  useEffect(() => {
    if (!ref.current) return
    ref.current.srcObject = stream
  }, [stream])

  return (
    <div>
      <video ref={ref} autoPlay />

      <button onClick={state === 'closed' ? open : close}>
        {state === 'open' ? 'Stop Sharing' : 'Share Screen'}
      </button>
    </div>
  )
}
```

## API Reference

<AutoTypeTable
  name="UseDisplayMediaOptions"
  description={
    <>
      The options of the useDisplayMedia hook. See&nbsp;
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia#options">
        MDN docs
      </a>
      &nbsp; for more details.
    </>
  }
  path="packages/use-display-media/src/index.ts"
/>
<AutoTypeTable
  name="UseDisplayMediaReturn"
  description="Return value of the useDisplayMedia hook."
  path="packages/use-display-media/src/index.ts"
/>

---

# useDocumentHasFocus

Track the focus state of the document.

## Installation

```package-install
npm install @1hook/use-document-has-focus
```

## Usage

```tsx twoslash include imports
import { useDocumentHasFocus } from '@1hook/use-document-has-focus'
```

Track the document visibility:

```tsx twoslash
// @include: imports
// ---cut---
const hasFocus = useDocumentHasFocus()
```

## API Reference

<AutoTypeTable
  name="UseDocumentHasFocusOptions"
  description="The options for the useDocumentHasFocus hook."
  path="packages/use-document-has-focus/src/index.ts"
/>

---

# useDocumentVisibility

Track the visibility of the document.

## Installation

```package-install
npm install @1hook/use-document-visibility
```

## Usage

```tsx twoslash include imports
import { useDocumentVisibility } from '@1hook/use-document-visibility'
```

Track the document visibility:

```tsx twoslash
// @include: imports
// ---cut---
const isVisible = useDocumentVisibility()
```

## API Reference

<AutoTypeTable
  name="UseDocumentVisibilityOptions"
  description="The options for the useDocumentVisibility hook."
  path="packages/use-document-visibility/src/index.ts"
/>

---

# useEventHandler

Stabilize a function's reference across renders. The function is always up to date in effects and DOM events.

<Callout title="Deprecated" type="warn">
  For React 19.2.0+, use the built-in `useEffectEvent` hook instead.
</Callout>

## Installation

```package-install
npm install @1hook/use-event-handler
```

## Usage

```tsx twoslash include imports
import { useEventHandler } from '@1hook/use-event-handler'
```

Provide a function to `useEventHandler`:

```tsx twoslash include onData
// @include: imports
const props = {
  onData: (data: any) => {},
}
// ---cut---
const onData = useEventHandler(props.onData)
```

`onData` now has a stable identity, making it safe to use in `useEffect`.

```tsx twoslash
import { useEffect } from 'react'
// @include: onData
// ---cut---
useEffect(() => {
  // only runs once
}, [onData])
```

---

# useEventListener

React version of `addEventListener`, optimized for performance and memory usage.

## Installation

```package-install
npm install @1hook/use-event-listener
```

## Usage

```tsx twoslash include imports
const console = { log: (_: any) => {} }
// ---cut---
import { useEventListener } from '@1hook/use-event-listener'
```

Attach an event listener to the target.

```tsx twoslash
// @include: imports
const target = document.getElementById('target')
// ---cut---
useEventListener(target, 'click', () => console.log('click'))
```

### Target a DOM Element

You can use `useEventListener` to attach event listeners to specific DOM elements.

Using a ref:

```tsx twoslash
// @include: imports
import React, { useRef } from 'react'
// ---cut---
function MyComponent() {
  const ref = useRef<HTMLDivElement | null>(null)

  useEventListener(ref, 'scroll', (e) => console.log('scroll'))

  return <div ref={ref} />
}
```

Using a stateful element:

```tsx twoslash
// @include: imports
import React, { useState } from 'react'
// ---cut---
function MyComponent() {
  const [target, setTarget] = useState<HTMLDivElement | null>(null)

  useEventListener(target, 'scroll', (e) => console.log('scroll'))

  return <div ref={setTarget} />
}
```

Using querySelector:

```tsx twoslash
// @include: imports
import React from 'react'
// ---cut---
function MyComponent() {
  const target = document.querySelector('body > .scrollable')

  useEventListener(target, 'scroll', (e) => console.log('scroll'))

  return <div />
}
```

### Target the window / document

For single-page applications (SPAs), you can directly use the `window` or `document` object:

```tsx twoslash
// @include: imports
const target = document.getElementById('target')
// ---cut---
useEventListener(window, 'click', (e) => console.log(e.target))
```

With SSR, you need to check if the code runs on the server before accessing the window object:

```tsx twoslash
// @include: imports
const target = document.getElementById('target')
// ---cut---
import { isServer } from '@1hook/use-event-listener'

useEventListener(!isServer && window, 'click', (e) => console.log(e.target))
```

### Trigger the listener manually

This example shows how to listen for the `'mousemove'` & `'mouseup'` global events only after the `'mousedown'` event has occurred.

```tsx twoslash
// @include: imports
// ---cut---
useEventListener(document.getElementById('target'), 'mousedown', (e) => {
  // Activate mousemove and mouseup listeners after mousedown occurs
  mousemoveListener.add()
  mouseupListener.add()
})

const mousemoveListener = useEventListener(
  document,
  'mousemove',
  (e) => console.log('Mouse Move'),
  { autoListen: false }, // Do not attach the listener automatically
)

const mouseupListener = useEventListener(
  document,
  'mouseup',
  (e) => {
    // Remove both listeners after mouseup event
    mousemoveListener.remove()
    mouseupListener.remove()
  },
  { autoListen: false }, // Do not attach the listener automatically
)
```

## API Reference

<TableTitle value="Parameters" />

<TableDescription
  value={
    <>
      The <code>useEventListener</code> hook accepts four arguments:
    </>
  }
/>

| Argument                             | Description                                                                                                                                                                                                                                                                     |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <pre>(1) <Code>target</Code></pre>   | The element to attach the listener to.                                                                                                                                                                                                                                          |
| <pre>(2) <Code>type</Code></pre>     | See [MDN Docs](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#parameters)                                                                                                                                                                        |
| <pre>(3) <Code>listener</Code></pre> | See [MDN Docs](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#parameters)                                                                                                                                                                        |
| <pre>(4) <Code>options</Code></pre>  | Event listener options (see [MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#parameters)) with the following differences:<br/>- `autoListen`: if `false` the listener is not attached automatically on mount.<br/>- `signal` is omitted |

<AutoTypeTable
  name="UseEventListenerReturn"
  description="What `useEventListener` returns"
  path="packages/use-event-listener/src/index.ts"
/>

---

# useGeolocation

Access and watch the browser's geolocation data.

## Installation

```package-install
npm install @1hook/use-geolocation
```

## Usage

```tsx twoslash include imports
import { useGeolocation } from '@1hook/use-geolocation'
```

When mounted, this hook begins tracking the user's location. \
If location permissions haven't been granted yet, the browser will request permission from the user.

```tsx twoslash
// @include: imports
import React from 'react'
// ---cut---
function LocationDisplay() {
  const { coords, state, error } = useGeolocation()

  if (state === 'loading') {
    return <div>Loading location...</div>
  }

  if (state === 'error') {
    return <div>Error: {error.message}</div>
  }

  return (
    <div>
      <div>Latitude: {coords.latitude}</div>
      <div>Longitude: {coords.longitude}</div>
    </div>
  )
}
```

## API Reference

<AutoTypeTable
  name="UseGeolocationOptions"
  description={
    <>
      Options for the <code>useGeolocation</code> hook. See&nbsp;
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition#parameters">
        MDN docs
      </a>
      &nbsp; for more details.
    </>
  }
  path="packages/use-geolocation/src/index.ts"
/>

<AutoTypeTable
  name="UseGeolocationReturn"
  description={
    <>
      The return value of the <code>useGeolocation</code> hook.
    </>
  }
  path="packages/use-geolocation/src/index.ts"
/>

---

# useGetIsMounted

Check if a component is still mounted to avoid memory leaks.

## Installation

```package-install
npm install @1hook/use-get-is-mounted
```

## Usage

```tsx twoslash include imports
import { useGetIsMounted } from '@1hook/use-get-is-mounted'
```

Get the mounted state of the component at any time

```tsx twoslash
const console = { log: (_: any) => {} }
// @include: imports
// ---cut---
const getIsMounted = useGetIsMounted()

console.log(getIsMounted())
```

---

# useGlobalState

Minimalistic & Performant global state manager.

## Installation

```package-install
npm install @1hook/use-global-state
```

## Quick Start

<Steps>

<Step>
### Define the global state

```tsx twoslash title="use-count.ts" include use-count
import { defineGlobalState } from '@1hook/use-global-state'

export const [useCount] = defineGlobalState({ initialState: 0 })
```

</Step>

<Step>
### Use like useState

```tsx twoslash
// @include: use-count
// ---cut---
const [count, setCount] = useCount()
```

</Step>
</Steps>

## Prevent unnecessary rerenders

To help prevent unnecessary rerenders, `defineGlobalState` provides a standalone setter function. \
It helps prevent unnecessary rerenders by not listening to the state.

```tsx twoslash title="use-count.ts" include set-count
import { defineGlobalState } from '@1hook/use-global-state'
// ---cut---
export const [useCount, setCount] = defineGlobalState({ initialState: 0 })
```

‚úÖ No rerender when count changes:

```tsx twoslash
// @noErrors
// @include: set-count
// ---cut---
import { setCount } from './use-count'

function Increment1() {
  return (
    <button onClick={() => setCount((count) => count + 1)}>Increment</button>
  )
}
```

‚ùå Rerenders when count changes:

```tsx twoslash
// @noErrors
// @include: set-count
// ---cut---
import { useCount } from './use-count'

function Increment1() {
  const [count, setCount] = useCount()

  return (
    <button onClick={() => setCount((count) => count + 1)}>Increment</button>
  )
}
```

---

# useInView

Track the visibility of an element.

## Installation

```package-install
npm install @1hook/use-in-view
```

## Usage

```tsx twoslash include imports
import { useInView } from '@1hook/use-in-view'
```

Track the visibility of an element:

```tsx twoslash
// @include: imports
import React from 'react'
// ---cut---
function MyComponent() {
  const { ref, inView } = useInView()

  return <div ref={ref}>...</div>
}
```

Set a default value until the target is observed:

```tsx twoslash
// @include: imports
import React from 'react'
// ---cut---
function MyComponent() {
  const { ref, inView = true } = useInView()

  return <div ref={ref}>...</div>
}
```

Customize the intersection observer:

```tsx twoslash
// @include: imports
import React from 'react'
// ---cut---
function MyComponent() {
  const { ref, inView } = useInView({
    root: document.querySelector('#root'),
    rootMargin: '10px',
    threshold: 0.5,
  })

  return <div ref={ref}>...</div>
}
```

Observe once:

```tsx twoslash
// @include: imports
import React from 'react'
// ---cut---
function MyComponent() {
  const { ref, unobserve } = useInView({
    onChange: (inView) => inView && unobserve(),
  })

  return <div ref={ref}>...</div>
}
```

## API Reference

<AutoTypeTable
  name="UseInViewOptions"
  description="Options for the useInView hook."
  path="packages/use-in-view/src/index.ts"
/>

<AutoTypeTable
  name="UseInViewReturn"
  description="Return value for the useInView hook."
  path="packages/use-in-view/src/index.ts"
/>

---

# useIntersectionObserver

The IntersectionObserver API, reactified, simplified and optimized.

## Features

- **Instance Reuse:** Optimizes performance by reusing IntersectionObserver instances based on options.
- **Convenient Unwrapping:** Automatically unwraps the entries parameter, allowing direct access to each entry in the callback.
- **Manual Observation Control:** Allows manual control over observation using the `observe` and `unobserve` functions.

## Installation

```package-install
npm install @1hook/use-intersection-observer
```

## Usage

```tsx twoslash include imports
import { useIntersectionObserver } from '@1hook/use-intersection-observer'
```

Observe an element's intersection with the viewport:

```tsx twoslash
// @include: imports
import React from 'react'
const console = { log: (_: any) => {} }
// ---cut---
function MyComponent() {
  const { ref } = useIntersectionObserver((entry) => {
    console.log({ isIntersecting: entry.isIntersecting })
  })

  return <div ref={ref} />
}
```

Customize the intersection observer:

```tsx twoslash
// @include: imports
import React from 'react'
const console = { log: (_: any) => {} }
// ---cut---
function MyComponent() {
  const { ref } = useIntersectionObserver(
    (entry) => console.log({ isIntersecting: entry.isIntersecting }),
    { rootMargin: '100px' },
  )

  return <div ref={ref} />
}
```

Stop observing the target after the first intersection:

```tsx twoslash
// @include: imports
import React from 'react'
const console = { log: (_: any) => {} }
// ---cut---
function MyComponent() {
  const { ref, unobserve } = useIntersectionObserver((entry) => {
    if (!entry.isIntersecting) return
    console.log('Intersected!')
    unobserve()
  })

  return <div ref={ref} />
}
```

## API Reference

<AutoTypeTable
  name="UseIntersectionObserverOptions"
  description="Options for the useIntersectionObserver hook."
  path="packages/use-intersection-observer/src/index.ts"
/>

<AutoTypeTable
  name="UseIntersectionObserverReturn"
  description="Return value for the useIntersectionObserver hook."
  path="packages/use-intersection-observer/src/index.ts"
/>

---

# useInterval

setInterval reactified, with synchronization support.

## Installation

```package-install
npm install @1hook/use-interval
```

## Usage

```tsx twoslash include imports
const console = { log: (_: any) => {} }
// ---cut---
import { useInterval } from '@1hook/use-interval'
```

Set an interval:

```tsx twoslash
// @include: imports
// ---cut---
const { cancel, reset, isPending } = useInterval(() => {
  console.log('Hello')
}, 1000)
```

Pause the interval by setting the delay to `null`:

```ts twoslash
// @include: imports
// ---cut---
useInterval(() => console.log('Hello'), null)
```

Execute immediately by setting the `leading` option to `true`:

```ts twoslash
// @include: imports
// ---cut---
useInterval(() => console.log('Hello'), 1000, { leading: true })
```

Synchronize all intervals that share the same delay using the `sync` option:

```ts twoslash
// @include: imports
// ---cut---
useInterval(() => console.log('Hello'), 1000, { sync: true })
```

## API Reference

<AutoTypeTable
  name="UseIntervalOptions"
  description="Options for the useInterval hook (3rd argument)."
  path="packages/use-interval/src/index.ts"
/>

<AutoTypeTable
  name="UseIntervalReturn"
  description="Return value of the useInterval hook."
  path="packages/use-interval/src/index.ts"
/>

---

# useInvariantContext

useContext that throws if the provider is not found.

## Installation

```package-install
npm install @1hook/use-invariant-context
```

## Usage

```tsx twoslash include imports
import React, { createContext } from 'react'
type Value = any[]
const MyContext = React.createContext<Value | null>(null)
// ---cut---
import { useInvariantContext } from '@1hook/use-invariant-context'
```

An error is thrown if the context value is falsy.

```tsx twoslash
// @include: imports
// @noErrors
// ---cut---
const ctx = useInvariantContext(MyContext)

// optionally pass a custom error message

const ctx = useInvariantContext(MyContext, 'Context not found')
```

## Example

This example shows how to use `useInvariantContext` to avoid missing context provider.

```tsx twoslash
import { useInvariantContext } from '@1hook/use-invariant-context'
import React, { createContext, ReactNode, useContext } from 'react'
type Value = any[]
// @noErrors
// ---cut---
const MyContext = createContext<Value | null>(null)

type Props = { children: ReactNode; initialValue: Value }

export function MyProvider({ children, initialValue }: Props) {
  return (
    <MyContext.Provider value={initialValue}>{children}</MyContext.Provider>
  )
}

// ‚ùå returns `Value | null` since there is not garantee that the context provider is present
export const useMyContext = () => useContext(MyContext)

// ‚úÖ returns `Value` or throws an error if the context provider is not found
export const useMyContext = () => useInvariantContext(MyContext)
```

---

# useIsHydrated

Once `true`, no hydration error can occur.

Prevent hydration mismatches by conditionally rendering content that depends on browser APIs.

## Installation

```package-install
npm install @1hook/use-is-hydrated
```

## Usage

```tsx twoslash include imports
import { useIsHydrated } from '@1hook/use-is-hydrated'
```

Check if the component is hydrated:

```tsx twoslash
import React from 'react'
// @include: imports
// ---cut---
function MyComponent() {
  const isHydrated = useIsHydrated()

  if (!isHydrated) return null

  return <div>{Date.now()}</div>
}
```

---

# useIsOnline

Track the online state of the browser.

## Installation

```package-install
npm install @1hook/use-is-online
```

## Usage

```tsx twoslash include imports
import { useIsOnline } from '@1hook/use-is-online'
```

Check if the browser is online:

```tsx twoslash
// @include: imports
// ---cut---
const isOnline = useIsOnline()
```

---

# useLatestRef

Transform anything into a ref. The ref is always up to date in effects and DOM events.

## Installation

```package-install
npm install @1hook/use-latest-ref
```

## Usage

```tsx twoslash include imports
import { useLatestRef } from '@1hook/use-latest-ref'
```

Transform any value into a ref:

```tsx twoslash
// @include: imports
type Value = any[]
const value: Value = []
// ---cut---
const ref = useLatestRef(value)
```

Use `ref.current` to read the latest `value` in effects, changes to `value` do not trigger the effect.

```tsx twoslash
// @include: imports
const console = { log: (..._: any[]) => {} }
import { useEffect } from 'react'
type Value = any[]
const value: Value = []
const ref = useLatestRef(value)
// ---cut---
useEffect(() => {
  // only runs once
  console.log('value', ref.current)
}, [ref])
```

---

# useLockBodyScroll

Lock and unlock the body scroll without layout shift.

## Installation

```package-install
npm install @1hook/use-lock-body-scroll
```

## Usage

```tsx twoslash include imports
import { useLockBodyScroll } from '@1hook/use-lock-body-scroll'
```

The body scroll is automatically unlocked when the hook unmounts.

```tsx twoslash
// @include: imports
// ---cut---
const { lock, unlock, locked } = useLockBodyScroll()
```

Lock on mount:

```tsx twoslash
import { useEffect } from 'react'
// @include: imports
// ---cut---
const { lock } = useLockBodyScroll()

useEffect(lock, [lock])
```

---

# useMediaRecorder

Record media streams.

## Installation

```package-install
npm install @1hook/use-media-recorder
```

## Usage

```tsx twoslash include imports
import React from 'react'
const stream = new MediaStream()
//---cut---
import { useMediaRecorder } from '@1hook/use-media-recorder'
```

The recording automatically starts when a media stream is provided and stops when the stream is nullish.

```tsx twoslash
// @include: imports
import { useState } from 'react'
const [recordingSrc, setRecordingSrc] = useState<string>()
// ---cut---
useMediaRecorder(stream, {
  onComplete(chunks) {
    const blob = new Blob(chunks, { type: 'video/webm' })
    const url = URL.createObjectURL(blob)
    setRecordingSrc(url)
  },
})
```

You can pause and resume the recording:

```tsx twoslash
// @include: imports
// ---cut---
const { pause, resume } = useMediaRecorder(stream, {
  onComplete(chunks) {
    // transform the chunks into a file or url
  },
})
```

Transform the recorded data into a File:

```tsx twoslash
// @include: imports
import { useState } from 'react'
const [file, setFile] = useState<File>()
// ---cut---
const { pause, resume } = useMediaRecorder(stream, {
  onComplete(chunks) {
    const type = 'video/webm'
    const blob = new Blob(chunks, { type })
    const file = new File([blob], 'recording.webm', { type })
    setFile(file)
  },
})
```

## Example

Record video from the device's camera:

```tsx twoslash include imports
import React from 'react'
// ---cut---
import { useMediaRecorder } from '@1hook/use-media-recorder'
import { useUserMedia } from '@1hook/use-user-media'
import { useState } from 'react'

export default function VideoRecorder() {
  const [recordingSrc, setRecordingSrc] = useState<string>()

  const media = useUserMedia({ video: true })

  const recorder = useMediaRecorder(media.stream, {
    onComplete(chunks) {
      const blob = new Blob(chunks, { type: 'video/webm' })
      const src = URL.createObjectURL(blob)
      setRecordingSrc(src)
    },
  })

  return (
    <div>
      {recordingSrc && <video src={recordingSrc} controls />}

      {recorder.state === 'inactive' && (
        <button onClick={media.open}>Start Recording</button>
      )}
      {recorder.state === 'recording' && (
        <button onClick={media.close}>Stop Recording</button>
      )}
    </div>
  )
}
```

## API Reference

<AutoTypeTable
  name="UseMediaRecorderOptions"
  description={
    <>
      The options of the useMediaRecorder hook. See&nbsp;
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/MediaRecorder#options">
        MDN docs
      </a>
      &nbsp; for more details.
    </>
  }
  path="packages/use-media-recorder/src/index.ts"
/>

<AutoTypeTable
  name="UseMediaRecorderReturn"
  description="The return value of the useMediaRecorder hook."
  path="packages/use-media-recorder/src/index.ts"
/>

---

# useMergeRefs

Merge refs, returns a callback ref.

## Installation

```package-install
npm install @1hook/use-merge-refs
```

## Usage

```tsx twoslash include imports
import { useMergeRefs } from '@1hook/use-merge-refs'
```

Merge refs:

```tsx twoslash
// @include: imports
import { useRef } from 'react'
const forwardedRef = useRef<HTMLDivElement | null>(null)
const internalRef = useRef<HTMLDivElement | null>(null)
// ---cut---
const ref = useMergeRefs(forwardedRef, internalRef)
```

`ref` is a callback ref.

---

# useMountEffect

Execute the callback when the component mounts (first effect).

## Installation

```package-install
npm install @1hook/use-mount-effect
```

## Usage

```tsx twoslash include imports
import { useMountEffect } from '@1hook/use-mount-effect'
```

Execute a function on mount:

```tsx twoslash
// @include: imports
const console = { log: (..._: any[]) => {} }
// ---cut---
useMountEffect(() => console.log('Mounted!'))
```

---

# useMutationObserver

The MutationObserver API, reactified and simplified

## Installation

```package-install
npm install @1hook/use-mutation-observer
```

## Usage

```tsx twoslash include imports
import { useMutationObserver } from '@1hook/use-mutation-observer'
```

Observe an element‚Äôs child list mutation:

```tsx twoslash
// @include: imports
import React from 'react'
const console = { log: (..._: any[]) => {} }
// ---cut---
function MyComponent() {
  const { ref } = useMutationObserver(
    (entry) => console.log("The element's child list has changed!"),
    { childList: true },
  )

  return <div ref={ref} />
}
```

Manual observation control:

```tsx twoslash
// @include: imports
import React from 'react'
const console = { log: (..._: any[]) => {} }
// ---cut---
function MyComponent() {
  const { ref, observe, unobserve } = useMutationObserver(
    (entry) => console.log("The element's child list has changed!"),
    { childList: true, autoObserve: false }, // Disable automatic observation
  )

  return (
    <div>
      <div ref={ref} />

      <button onClick={observe}>Start observing</button>

      <button onClick={unobserve}>Stop observing</button>
    </div>
  )
}
```

## API Reference

<AutoTypeTable
  name="UseMutationObserverOptions"
  description={
    <>
      The options for the useMutationObserver hook. See&nbsp;
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe#options">
        MDN docs
      </a>
      &nbsp;for more details.
    </>
  }
  path="packages/use-mutation-observer/src/index.ts"
/>

<AutoTypeTable
  name="UseMutationObserverReturn"
  description="The return value of the useMutationObserver hook."
  path="packages/use-mutation-observer/src/index.ts"
/>

---

# useNavigatorPermission

Query and track navigator permissions.

## Installation

```package-install
npm install @1hook/use-navigator-permission
```

## Usage

```tsx twoslash include imports
import { useNavigatorPermission } from '@1hook/use-navigator-permission'
```

Query a permission state:

```tsx twoslash
// @include: imports
const console = { log: (_: any) => {} }
// ---cut---
const permission = useNavigatorPermission({ name: 'geolocation' })

console.log(permission.state)
```

The state will be updated in real-time as the user interacts with the browser.

## API Reference

<AutoTypeTable
  name="UseNavigatorPermissionOptions"
  description="The options for the useNavigatorPermission hook."
  path="packages/use-navigator-permission/src/index.ts"
/>

<AutoTypeTable
  name="UseNavigatorPermissionReturn"
  description="The return value of the useNavigatorPermission hook."
  path="packages/use-navigator-permission/src/index.ts"
/>

---

# usePrevious

Returns the previous value.

## Installation

```package-install
npm install @1hook/use-previous
```

## Usage

```tsx twoslash include imports
import { usePrevious } from '@1hook/use-previous'
```

Get the previous value:

```tsx twoslash
// @include: imports
const value: number = 0
// ---cut---
const previous = usePrevious(value)
```

Custom `isEqual` function to compare the previous and current values.

```tsx
import { isEqual } from 'lodash'

const previous = usePrevious(value, { isEqual })
```

## API Reference

<AutoTypeTable
  name="UsePreviousOptions"
  description="The options for the usePrevious hook."
  path="packages/use-previous/src/index.ts"
/>

---

# useRerender

Trigger rerenders on-demand.

## Installation

```package-install
npm install @1hook/use-rerender
```

## Usage

```tsx twoslash include imports
import { useRerender } from '@1hook/use-rerender'
```

Rerender a component:

```tsx twoslash
// @include: imports
// ---cut---
const rerender = useRerender()

rerender()
```

---

# useResizeObserver

The React version of the ResizeObserver API.

## Installation

```package-install
npm install @1hook/use-resize-observer
```

## Usage

```tsx twoslash include imports
import { useResizeObserver } from '@1hook/use-resize-observer'
```

Observe an element:

```tsx twoslash
// @include: imports
const console = { log: (..._: any[]) => {} }
import React from 'react'
// ---cut---
function MyComponent() {
  const { ref } = useResizeObserver((entry) => {
    console.log('The target element has been resized!')
  })

  return <div ref={ref} />
}
```

Manual observation control:

```tsx twoslash
// @include: imports
const console = { log: (..._: any[]) => {} }
import React from 'react'
// ---cut---
function MyComponent() {
  const { ref, observe, unobserve } = useResizeObserver(
    (entry) => console.log('Resized!'),
    { autoObserve: false }, // Disable automatic observation
  )

  return (
    <div>
      <div ref={ref} />

      <button onClick={observe}>Start observing</button>

      <button onClick={unobserve}>Stop observing</button>
    </div>
  )
}
```

## API Reference

<AutoTypeTable
  name="UseResizeObserverOptions"
  description={
    <>
      The options for the useResizeObserver hook. See&nbsp;
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/observe#options">
        MDN docs
      </a>
      for more details.
    </>
  }
  path="packages/use-resize-observer/src/index.ts"
/>

<AutoTypeTable
  name="UseResizeObserverReturn"
  description="The return value of the useResizeObserver hook."
  path="packages/use-resize-observer/src/index.ts"
/>

---

# useSize

Track the size of an element.

## Installation

```package-install
npm install @1hook/use-size
```

## Usage

```tsx twoslash include imports
import { useSize } from '@1hook/use-size'
```

Observe an element:

```tsx twoslash
// @include: imports
import React from 'react'
// ---cut---
function MyComponent() {
  const { ref, width, height } = useSize()

  return <div ref={ref}>...</div>
}
```

Provide default values:

```tsx twoslash
// @include: imports
import React from 'react'
// ---cut---
const { ref, width = 0, height = 0 } = useSize()
```

## API Reference

<AutoTypeTable
  name="UseSizeOptions"
  description="The options for the useSize hook."
  path="packages/use-size/src/index.ts"
/>

<AutoTypeTable
  name="UseSizeReturn"
  description="The return value of the useSize hook."
  path="packages/use-size/src/index.ts"
/>

---

# useSpeechSynthesis

Web Speech API synthesis, reactified.

## Installation

```package-install
npm install @1hook/use-speech-synthesis
```

## Usage

```tsx twoslash include imports
import { useSpeechSynthesis } from '@1hook/use-speech-synthesis'
```

Basic text-to-speech:

```tsx twoslash
// @include: imports
// ---cut---
const { speak } = useSpeechSynthesis()

speak('Hello, world!')
```

Configure speech options:

```tsx twoslash
// @include: imports
// ---cut---
const { speak } = useSpeechSynthesis({
  lang: 'fr-FR',
  pitch: 1.5,
  rate: 0.8,
  volume: 0.7,
})

speak('Bonjour le monde!')
```

Cancel speaking and check the current state:

```tsx twoslash
const console = { log: (_: any) => {} }
// @include: imports
// ---cut---
const { speak, cancel, state } = useSpeechSynthesis()

console.log(state) // state === 'idle'
speak('Hello, world!')
console.log(state) // state === 'speaking'
cancel()
console.log(state) // state === 'idle'
```

## API Reference

<AutoTypeTable
  name="UseSpeechSynthesisOptions"
  description={
    <>
      The options for the useSpeechSynthesis hook. See&nbsp;
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesisUtterance">
        MDN docs
      </a>
      &nbsp;for more details.
    </>
  }
  path="packages/use-speech-synthesis/src/index.ts"
/>

<AutoTypeTable
  name="UseSpeechSynthesisReturn"
  description="The return value of the useSpeechSynthesis hook."
  path="packages/use-speech-synthesis/src/index.ts"
/>

---

# useStorage

A simple typesafe state manager using localStorage or sessionStorage.

## Features

- **Built-in Validation:** Validate with [zod](https://zod.dev/), [valibot](https://valibot.dev/), [arktype](https://arktype.dev/) or with a simple function.
- **Tab Sync:** The state is synced across multiple browser tabs when using the `localStorage`.
- **Component Sync:** The state is synced across all components.

## Installation

```package-install
npm install @1hook/use-storage
```

## Quick Start

<Steps>
<Step>
### Setup the State

Use defineCookie to configure validation rules and the type of storage.

```tsx twoslash title="sidebar-width.ts" include sidebar-width
import { z } from 'zod'
import { defineStorage } from '@1hook/use-storage'

export const [useSidebarWidth] = defineStorage({
  key: 'sidebar-width',
  validate: z.number().default(200),
  type: 'local',
})
```

</Step>

<Step>
### Read and Write.

Changes to the state are synchronized across all instances of the hook and across browser tabs.

```tsx twoslash title="layout.tsx"
// @noErrors
// @include: sidebar-width
// ---cut---
function Layout() {
  const [width, setWidth] = useSidebarWidth()

  return (
    <div>
      <Sidebar width={width} onResize={setWidth} />
      <main>...</main>
    </div>
  )
}
```

Storage updates are automatically synchronized across all instances of the hook and across browser tabs.

</Step>
</Steps>

## Validation

To ensure data integrity, the storage should be validated.

### üëâ Functional validation

For simple cases you can use a function to validate the storage.

```ts twoslash
import { defineStorage } from '@1hook/use-storage'
// ---cut---
defineStorage({
  key: 'search',
  validate: (value) => String(value ?? ''),
  type: 'local',
})
```

### üëâ Schema validation

For more complex cases you can use a schema to validate the storage. Compatible validation libraries include [zod 3.24+](https://zod.dev/), [valibot
1.0+](https://valibot.dev/) or [arktype 2.0+](https://arktype.dev/). Check out [Standard
Schema](https://github.com/standard-schema/standard-schema) for more info.

```ts twoslash
import { defineStorage } from '@1hook/use-storage'
// ---cut---
import { z } from 'zod'

defineStorage({
  key: 'search',
  validate: z.string().default(''),
  type: 'local',
})
```

## Outside of React

`defineStorage` returns a standalone utility object that provides methods to `get`, `set` or `clear` the value outside of React components.

```ts twoslash include storage-outside
import { z } from 'zod'
import { defineStorage } from '@1hook/use-storage'
// ---cut---
export const [useStorage, Storage] = defineStorage({
  key: 'my-storage',
  validate: z.string().optional(),
  type: 'local',
})
```

Using it still triggers a **React re-render**.

```tsx twoslash
// @noErrors
// @include: storage-outside
// ---cut---
import { Storage } from './storage'

// Write
Storage.set('new-value')

// Read
Storage.get()

// Clear
Storage.clear()
```

<hr />

## API Reference

### üëâ defineStorage

```ts
function defineStorage(options?: DefineStorageOptions): [useStorage, Storage]
```

<AutoTypeTable
  name="DefineStorageOptions"
  description="The options of the storage service."
  path="packages/use-storage/src/index.ts"
/>

### üëâ useStorage

Manage storage state like with useState.

```ts
function useStorage(): [state, setState]
```

### üëâ Storage

Read and write to the storage outside of React.

---

# useThrottleFn

A throttle function, reactified.

Ensures that a function is only executed once in a specified time interval, no matter how many times it is invoked.

## Installation

```package-install
npm install @1hook/use-throttle-fn
```

## Usage

```tsx twoslash include imports
import { useThrottleFn } from '@1hook/use-throttle-fn'
```

The `useThrottleFn` hook accepts an interval in milliseconds and returns a `throttle` function.

The first call executes right away, while subsequent calls within interval are throttled. \
The final call is scheduled to run after the interval expires.

```tsx twoslash
// @include: imports
const console = { log: (..._: any[]) => {} }
// ---cut---
const { throttle } = useThrottleFn(1000)

throttle(() => console.log('Executes immediately'))
throttle(() => console.log('Skipped'))
throttle(() => console.log('Scheduled to execute after 1000ms'))
```

Override the default interval:

```diff lang='tsx'
const { throttle } = useThrottleFn(1000)

throttle(() => console.log('Executes immediately'))
throttle(() => console.log('Scheduled to execute after 500ms'), 500)
```

Use `trailing: false` to avoid scheduling the last call:

```tsx twoslash
// @include: imports
const console = { log: (..._: any[]) => {} }
// ---cut---
const { throttle } = useThrottleFn(1000, { trailing: false })

throttle(() => console.log('Executes immediately'))
throttle(() => console.log('Skipped'))
```

Cancel pending executions:

```tsx
const { throttle, cancel, isPending } = useThrottleFn(1000)

isPending && cancel()
```

When the component unmounts, pending executions are automatically canceled.

## API Reference

<AutoTypeTable
  name="UseThrottleFnOptions"
  description="The options of the useThrottleFn hook."
  path="packages/use-throttle-fn/src/index.ts"
/>

<AutoTypeTable
  name="UseThrottleFnReturn"
  description="The return value of the useThrottleFn hook."
  path="packages/use-throttle-fn/src/index.ts"
/>

---

# useTimeout

setTimeout, reactified.

## Installation

```package-install
npm install @1hook/use-timeout
```

## Usage

```tsx twoslash include imports
import { useTimeout } from '@1hook/use-timeout'
```

Set a timeout:

```tsx twoslash
// @include: imports
const console = { log: (..._: any[]) => {} }
// ---cut---
const { cancel, reset, isPending } = useTimeout(() => {
  console.log('Hello')
}, 1000)
```

Pause the timeout by setting the delay to `null`:

```ts twoslash
// @include: imports
const console = { log: (..._: any[]) => {} }
// ---cut---
useTimeout(() => console.log('Hello'), null)
```

## API Reference

<AutoTypeTable
  name="UseTimeoutReturn"
  description="The return value of the useTimeout hook."
  path="packages/use-timeout/src/index.ts"
/>

---

# useUnmountEffect

Execute the callback when the component unmounts (cleanup effect).

## Installation

```package-install
npm install @1hook/use-unmount-effect
```

## Usage

```tsx twoslash include imports
import { useUnmountEffect } from '@1hook/use-unmount-effect'
```

Execute a function on unmount:

```tsx twoslash
// @include: imports
const console = { log: (..._: any[]) => {} }
// ---cut---
useUnmountEffect(() => console.log('Unmounted!'))
```

---

# useUpdateEffect

useEffect without the initial effect.

## Installation

```package-install
npm install @1hook/use-update-effect
```

## Usage

```tsx twoslash include imports
import { useUpdateEffect } from '@1hook/use-update-effect'
```

Execute on dependency change:

```tsx twoslash
// @include: imports
const state: string = ''
const console = { log: (..._: any[]) => {} }
// ---cut---
useUpdateEffect(() => console.log('State has changed'), [state])
```

---

# useUserMedia

Access and manage media devices like camera and microphone.

## Installation

```package-install
npm install @1hook/use-user-media
```

## Usage

```tsx twoslash include imports
import { useUserMedia } from '@1hook/use-user-media'
```

Pass the media constraints to the hook.

```tsx twoslash
// @include: imports
// ---cut---
const { stream, open, close, state, error } = useUserMedia({
  video: true,
})
```

The hook follows a simple state machine:

- Initially starts in `"closed"` state with `stream: null`
- Calling `open()` transitions to `"loading"` state while requesting device access
- On successful device access, transitions to `"open"` state with `stream: MediaStream`
- If an error occurs during loading, transitions to `"error"` state with the error details
- Calling `close()` returns to `"closed"` state, stops the stream, and sets `stream: null`

This predictable state flow makes it easy to build UIs that respond appropriately to the media stream's status.

## Example

Capture and display video from the device's camera.

```tsx twoslash
import React from 'react'
// ---cut---
import { useEffect, useRef } from 'react'
import { useUserMedia } from '@1hook/use-user-media'

export default function VideoCapture() {
  const { state, stream, open, close } = useUserMedia({
    video: true,
  })

  const ref = useRef<HTMLVideoElement | null>(null)

  // use the stream to reproduce the video
  useEffect(() => {
    if (!ref.current) return
    ref.current.srcObject = stream
  }, [stream])

  return (
    <div>
      <video ref={ref} autoPlay />

      <button onClick={state === 'closed' ? open : close}>
        {state === 'closed' ? 'Open' : 'Close'} Camera
      </button>
    </div>
  )
}
```

### Parameters

<AutoTypeTable
  name="UseUserMediaOptions"
  description={
    <>
      The options of the useUserMedia hook. See&nbsp;
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints">
        MDN docs
      </a>
      &nbsp; for more details.
    </>
  }
  path="packages/use-user-media/src/index.ts"
/>

<AutoTypeTable
  name="UseUserMediaReturn"
  description="The return value of the useUserMedia hook."
  path="packages/use-user-media/src/index.ts"
/>

---

# useWebSocket

WebSocket client designed for React.

## Features

- **Built-in Validation:** Validate messages with [zod](https://zod.dev/), [valibot](https://valibot.dev/), [arktype](https://arktype.dev/) or with a simple function.
- **Connection Reuse:** Share a WebSocket connection across multiple hook instances.
- **Automatic Reconnect:** Configurable reconnection strategies for resilient connections.
- **Ping Support:** Built-in ping to keep connections alive.
- **Message Queueing:** Outgoing messages are queued while connecting.
- **Automatic Parsing/Serialization:** Customizable message parsing and serialization.
- **Friendly API:** Simple, ergonomic API for sending messages and tracking connection state.

## Installation

```package-install
npm install @1hook/use-websocket
```

## Quick Start

<Steps>

<Step>
### Setup the WebSocket

Define the ping and reconnect strategies for the useWebSocket hook.

```tsx twoslash title="websocket.ts" include imports
const console = { log: (..._: any[]) => {} }
import React from 'react'
// ---cut---
import { z } from 'zod'
import { defineWebSocket } from '@1hook/use-websocket'

export const useWebSocket = defineWebSocket({
  ping: { interval: 10000 },
  reconnect: { delay: 5000 },
})
```

</Step>

<Step>

### Send and Receive messages

Connect to a WebSocket server, validate and handle incoming messages.

```tsx twoslash
// @include: imports
// ---cut---
const { send } = useWebSocket({
  url: 'wss://echo.websocket.org',
  validate: z.object({ text: z.string() }),
  onMessage: console.log,
})
```

Use the `send` method the send messages to the server.

```tsx
send({ text: 'Hello!' })
```

All hooks using the same url + protocol share a single WebSocket connection. \

</Step>

</Steps>

## Validation

The `validate` option ensures incoming messages match your expected format, providing both runtime validation and type safety.

### üëâ Functional validation

For simple cases you can use a function to validate the incoming message.

```ts twoslash
// @include: imports
// ---cut---
useWebSocket({
  url: 'wss://echo.websocket.org',
  validate: (message) => String(message),
  onMessage: (message) => {
    // message: string
  },
})
```

### üëâ Schema validation

For more complex cases you can use a schema to validate the cookie value. Compatible validation libraries include [zod 3.24+](https://zod.dev/), [valibot
1.0+](https://valibot.dev/) or [arktype 2.0+](https://arktype.dev/). Check out [Standard
Schema](https://github.com/standard-schema/standard-schema) for more info.

```ts twoslash
// @include: imports
// ---cut---
useWebSocket({
  url: 'wss://echo.websocket.org',
  validate: z.object({ type: z.string(), text: z.string() }),
  onMessage: (message) => {
    // message: { type: string, text: string }
  },
})
```

## Message Filtering

Sometimes you need to selectively process messages based on their content. Rather than writing complex validation logic to handle every possible message format, you can simply ignore unwanted messages.

Return `null | undefined` from the `validate` option to skip processing specific messages. The hook will silently ignore these messages and only trigger `onMessage` for validated ones.

```ts twoslash
// @include: imports
// ---cut---
useWebSocket({
  url: 'wss://echo.websocket.org',
  validate: z
    .object({ type: z.string(), text: z.string() })
    .nullable() // allows returning null from catch() to ignore invalid messages
    .catch(null),
  onMessage: (message) => {
    // message: { type: string, text: string }
  },
})
```

Note that returning `null` or `undefined` from the `parseMessage` option will also ignore messages.

## Custom Parsing/Serialization

You can configure default message parsing and serialization in `defineWebSocket`, while still having the flexibility to override these settings in individual `useWebSocket` calls.

```ts twoslash
import { defineWebSocket } from '@1hook/use-websocket'
// ---cut---
defineWebSocket({
  parseMessage(event) {
    if (typeof event.data !== 'string') return event.data
    return JSON.parse(event.data)
  },
  serializeMessage(msg) {
    return JSON.stringify(msg)
  },
})
```

Since JSON parsing and serialization are the default behavior, you typically won't need to customize these settings.

## Typesafe message sending

Type the `serializeMessage` parameter to constrain what messages can be sent through the `send` method.

```ts twoslash include send
// @include: imports
// ---cut---
type OutgoingMessage = { type: string; text: string }

const { send } = useWebSocket({
  url: 'wss://echo.websocket.org',
  serializeMessage(message: OutgoingMessage) {
    return JSON.stringify(message)
  },
})
```

Now the `send` method only accepts messages matching the `OutgoingMessage` type.

```ts twoslash
// @include: send
// @noErrors
// ---cut---
// ‚úÖ ok
send({ type: 'hello', text: 'world' })

// ‚ùå error
send({ type: 'hello', text: 123 })
```

## Closing the connection

The WebSocket connection automatically closes when there are no more active listeners. The listeners are removed when

- the hook unmounts
- The url is set to `null`

Note that if the connection closes for any other reason (like network issues, server-side closure or using the close method of the WebSocket instance directly), the configured reconnection strategy will attempt to restore the connection.

```tsx twoslash
const enabled: boolean = true
// @include: imports
// ---cut---
useWebSocket({
  url: enabled ? 'wss://echo.websocket.org' : null,
})
```

## API Reference

### üëâ defineWebSocket

```ts
function defineWebSocket(options: DefineWebSocketOptions): useWebSocket
```

<AutoTypeTable
  name="DefineWebSocketOptions"
  description="Options for defineWebSocket."
  path="packages/use-websocket/src/define-websocket.ts"
/>

<AutoTypeTable
  name="WebSocketPingOption"
  description="The ping options."
  path="packages/use-websocket/src/vanilla.ts"
/>

<AutoTypeTable
  name="WebSocketReconnectOption"
  description="The reconnect options."
  path="packages/use-websocket/src/vanilla.ts"
/>

### üëâ useWebSocket

Send and Receive messages from a WebSocket server.

```ts
function useWebSocket(options: UseWebSocketOptions): UseWebSocketReturn
```

<AutoTypeTable
  name="UseWebSocketOptions"
  description="Options for the useWebSocket hook."
  path="packages/use-websocket/src/define-websocket.ts"
/>

<AutoTypeTable
  name="UseWebSocketReturn"
  description="Return value of the useWebSocket hook."
  path="packages/use-websocket/src/define-websocket.ts"
/>

---

# useWindowSize

Track the dimensions of the window.

## Features

- **Optimized performance:** Leverages a shared listener pool to reduce event subscriptions.
- **Custom state tracking:** disable internal state tracking with `trackState`.
- **Event-driven updates:** Provides an `onChange` callback for reacting to dimension changes.

## Installation

```package-install
npm install @1hook/use-window-size
```

## Usage

```tsx twoslash include imports
import { defineUseWindowSize } from '@1hook/use-window-size'

export const useWindowSize = defineUseWindowSize({ ssr: true })
```

Setting `ssr` to `true` initializes width and height as `undefined` to prevent hydration mismatches between server and client.

```tsx twoslash
// @include: imports
// ---cut---
const { width, height } = useWindowSize()
```

Use `trackState: false` to disable state tracking, the `onChange` callback is executed on mount and whenever the window size changes.

```tsx twoslash
// @include: imports
// ---cut---
useWindowSize({
  trackState: false,
  onChange(size) {
    if (size.width < 600) {
      // do something
    }
  },
})
```

## API Reference

<AutoTypeTable
  name="DefineUseWindowSizeOptions"
  description="Options for the `defineUseWindowSize` hook."
  path="packages/use-window-size/src/index.ts"
/>

<AutoTypeTable
  name="UseWindowSizeOptions"
  description="Options for the `useWindowSize` hook."
  path="packages/use-window-size/src/index.ts"
/>

<AutoTypeTable
  name="UseWindowSizeReturn"
  description="The return value of the `useWindowSize` hook."
  path="packages/use-window-size/src/index.ts"
/>

---

